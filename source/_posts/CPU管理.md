---
title: CPU管理

tags:
- 计算机基础
- 操作系统


---

## CPU的工作原理

`取指执行`:根据PC(程序计数器)中的地址,从内存中取得相应的指令,之后执行该指令

## 管理CPU最直观的方法

`设置好PC的初值`

## 该做法的一个问题

### 问题展示

#### 循环中有IO
```Java
import java.util.Date;

public class Solution {
    public static void main(String[] args) {
        Date date = new Date();
        long start = date.getTime();
        int a = 0;
        for (int i = 0; i < 100000; i++) {
            a ++;
            System.out.println(i);
        }
        System.out.println(new Date().getTime() - start);
    }
}
```

上面一段代码的执行结果为

```
1640
```

#### 循环中没有IO

```Java
public class Solution {
    public static void main(String[] args) {
        Date date = new Date();
        long start = date.getTime();
        int a = 0;
        for (int i = 0; i < 1000000000; i++) {
            a ++;
            a += 2;
        }
        System.out.println(new Date().getTime() - start);
    }
}
```
上面一段代码的执行结果为

```
4
```

可以看到`包含IO的程序`每轮循环的执行时间为`1.6*10-2`ms，而`不包含IO的程序`每轮循环执行时间为`4*10-9`ms，IO是非常耗时的操作。如果在程序进行IO操作时CPU一直等待，那么程序的执行效率将会非常低。

### 解决办法

为了解决这个问题，可以在程序正在执行IO等耗时操作时，CPU先执行其他进程，待IO操作执行完毕之后，再将CPU切换回来，继续执行该程序的后续操作。这样可以实现多个程序的并发，显著提高CPU的利用率。

`并发`: 同时出发，交替执行。

## 程序切换时的问题

### 问题展示

程序1：
```汇编
50: mov ax 1
51: mov bx 1
52: add ax bx
```
程序2：
```
200：mov ax 10
201：mov bx 10
202：add ax bx
```

程序从50开始执行，执行完51之后切换到200并开始执行，执行完201之后切换程序1开始执行52行，程序1的结果为20，而原本程序1的结果应该为2。

### 解决办法

为了解决这一问题，需要在程序切换时保存程序的状态。例如，在51行执行结束切换到200时，应该有一个结构保存当前执行到的行号、ax、bx的值等信息。每个程序都应该有一个这样的结构，这个结构被称为`PCB`（进程管理块）。

只有这样的运行中的程序需要记录状态信息，而存储起来的静态程序不需要记录这些信息，我们将这些运行中的程序称为`进程`。

进程与静态程序的区别：
- 进程有开始、暂停、结束等状态；而静态程序没有。
- 进程需要记录各个变量（如ax、bx）的信息；而静态程序不用。
- 进程会走走停停；而静态程序不会。

## 总结

操作系统执行一段程序，则CPU开始工作，但是如果CPU一直等待一个程序结束才开始别的程序，则IO等耗时操作可能导致CPU利用率过低，为此我们引入了`并发`的概念，并发的过程中可能会造成一个程序覆盖另一个程序的数据，为此，我们引入了`进程`的概念，在进程切换时，会使用一个名为`PCB`的结构保存程序的状态信息。