<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shaojunying&#39;s Blog</title>
  
  
  <link href="https://shaojunying.github.io/atom.xml" rel="self"/>
  
  <link href="https://shaojunying.github.io/"/>
  <updated>2021-04-06T11:58:40.437Z</updated>
  <id>https://shaojunying.github.io/</id>
  
  <author>
    <name>邵俊颖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AOP代理失效的两种情况</title>
    <link href="https://shaojunying.github.io/2021/04/06/AOP%E4%BB%A3%E7%90%86%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>https://shaojunying.github.io/2021/04/06/AOP%E4%BB%A3%E7%90%86%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5/</id>
    <published>2021-04-06T11:58:34.000Z</published>
    <updated>2021-04-06T11:58:40.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="被代理对象的private方法不能被代理"><a href="#被代理对象的private方法不能被代理" class="headerlink" title="被代理对象的private方法不能被代理"></a>被代理对象的private方法不能被代理</h2><ul><li>cdlib技术使用子类来代理父类，子类看不到父类的private，也就无法代理private方法。</li><li>JDK动态代理是基于接口来实现的，而接口不允许有private方法，也就不会有出现这个问题。</li></ul><h2 id="调用类内其他方法"><a href="#调用类内其他方法" class="headerlink" title="调用类内其他方法"></a>调用类内其他方法</h2><ul><li>如果方法a()调用处于同一个类内的方法b()，那么相当于this.b()，这里的this代表没有被代理的方法。</li></ul><p>为了解决这个问题，可以使用Autowired引入被代理之后的类，进而使用（被代理后的对象）调用类内方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;被代理对象的private方法不能被代理&quot;&gt;&lt;a href=&quot;#被代理对象的private方法不能被代理&quot; class=&quot;headerlink&quot; title=&quot;被代理对象的private方法不能被代理&quot;&gt;&lt;/a&gt;被代理对象的private方法不能被代理&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring解决循环依赖</title>
    <link href="https://shaojunying.github.io/2021/04/04/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>https://shaojunying.github.io/2021/04/04/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2021-04-04T06:09:29.000Z</published>
    <updated>2021-04-04T06:09:56.131Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.javazhiyin.com/70070.html">跳出源码地狱，Spring巧用三级缓存解决循环依赖-原理篇-Java知音</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用两级缓存即可解决循环依赖问题，但是Spring还需要支持AOP，对象被AOP之后会生成一个新的对象，如果在将实例注入之后再进行AOP，那么两个地方的对象将不一致。因此使用三级缓存，将对象的AOP提前到实例化进行。</p><h2 id="三级缓存的过程"><a href="#三级缓存的过程" class="headerlink" title="三级缓存的过程"></a>三级缓存的过程</h2><ol><li>尝试获取一个bean，发现bean不存在，于是实例化该bean，并放入三级缓存。</li><li>第二次尝试获取该bean，从三级缓存中找到bean，对该实例执行AOP，放入二级缓存并返回。</li><li>在初始化工作彻底完成之后，Spring将bean放入一级缓存，并从二三级缓存中删除。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/70070.html&quot;&gt;跳出源码地狱，Spring巧用三级缓存解决循环依赖-原理篇-Java知音&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《计算机网络》学习笔记</title>
    <link href="https://shaojunying.github.io/2021/04/04/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://shaojunying.github.io/2021/04/04/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-04-04T06:03:37.000Z</published>
    <updated>2021-04-04T06:07:31.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="五层网络模型"><a href="#五层网络模型" class="headerlink" title="五层网络模型"></a>五层网络模型</h2><p>分为应用层、传输层、网络层、数据链路层、物理层。</p><h2 id="现实中的网络模型"><a href="#现实中的网络模型" class="headerlink" title="现实中的网络模型"></a>现实中的网络模型</h2><p>将<strong>五层网络模型</strong>中的数据链路层和物理层合并为网络接口层</p><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p>将<strong>五层网络模型</strong>中的应用层拆分为会话层、表示层、应用层。</p><h1 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h1><ul><li><strong>物理层</strong>。将01比特从一台节点通过物理链路传递到另一个节点</li><li><strong>数据链路层</strong>。将数据分组从一个节点传递到另一个节点，同时提供差错检测和纠正的功能。</li><li><strong>网络层</strong>。将数据包从一台主机传递到另一台主机，提供的是一种尽力而为的服务。</li><li><strong>传输层</strong>。提供应用进程之间的数据传输服务。</li><li><strong>应用层</strong>。使用一些具体的协议传输数据。这些协议如HTTP、DNS、FTP、SMTP等。</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="SMTP和HTTP"><a href="#SMTP和HTTP" class="headerlink" title="SMTP和HTTP"></a>SMTP和HTTP</h2><p>HTTP是一个”拉”协议。客户端发起请求之后服务端发送响应。</p><p>SMTP是一个“推”协议。发送方mail服务器直接将邮件推到接收方服务器上。</p><h2 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h2><p>每个ISP通常都有一个本地DNS服务器</p><ol><li>主机想要获取一个域名对应的IP地址，则向本地DNS服务器发送请求。</li><li>本地DNS依次向根服务器以及各级服务器发送请求获取域名对应的IP地址（如果已有缓存则不用发送请求）。</li></ol><p>其中主机向本地DNS服务器发送请求是<strong>递归查询</strong>，本地DNS服务器向其他服务器发送请求是<strong>迭代查询</strong>。</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层提供的基本服务"><a href="#运输层提供的基本服务" class="headerlink" title="运输层提供的基本服务"></a>运输层提供的基本服务</h2><ul><li>数据交付</li><li>差错检测</li></ul><p>这也是UDP提供的仅有的两种服务。</p><h2 id="TCP提供的额外的服务"><a href="#TCP提供的额外的服务" class="headerlink" title="TCP提供的额外的服务"></a>TCP提供的额外的服务</h2><ul><li>可靠数据传输（包括序号、确认、定时器、流量控制）</li><li>拥塞控制</li></ul><h2 id="TCP的演化"><a href="#TCP的演化" class="headerlink" title="TCP的演化"></a>TCP的演化</h2><h3 id="停等协议（每次只发一条数据，确认后发送下一条数据）"><a href="#停等协议（每次只发一条数据，确认后发送下一条数据）" class="headerlink" title="停等协议（每次只发一条数据，确认后发送下一条数据）"></a>停等协议（每次只发一条数据，确认后发送下一条数据）</h3><ol><li>为了解决数据包出错的问题，引入<strong>确认</strong>（肯定确认和否定确认）机制。</li><li>确认帧可能受损，如果收到一个损坏的帧，就重发数据包。为了区分是重传还是新数据包，引入<strong>序号</strong>机制。</li><li>为了解决丢包问题，引入<strong>定时器</strong>机制。</li></ol><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><ul><li><strong>回退N步。</strong><ul><li>采用<strong>累计确认</strong></li><li>超时时发送方重传所有未确认分组</li></ul></li><li><strong>选择重传。</strong><ul><li>接收方缓存接受到的失序分组</li><li>接收到[recv_base - N, recv_base - 1] 和[recv_base, recv_base + N - 1]都需要发送ACK</li><li>窗口大小应该小于等于序号区间的一半。</li></ul></li></ul><h2 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h2><ul><li>累计确认。（发送确认帧时说明之前的帧都已收到）</li><li>超时间隔加倍。（超时的时候定时器的间隔加倍，收到ACK后会重新计算超时间隔）</li><li>快速重传：如果收到失序的数据，冗余发送3个ACK</li></ul><h2 id="TCP：回退N-or-选择重传"><a href="#TCP：回退N-or-选择重传" class="headerlink" title="TCP：回退N or 选择重传"></a>TCP：回退N or 选择重传</h2><p>TCP算是两者的结合体，使用累计确认的方法，但是接收方会缓存失序的帧。</p><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><ul><li><strong>接收窗口大小 = 缓冲区大小 - 已接收但是没有被上层使用的数据</strong></li><li>为了让发送方不会淹没接受方，发送方的<strong>已发送未确认数据大小应该≤接收窗口大小</strong></li></ul><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><strong>cwnd</strong>表示拥塞窗口大小，MSS为TCP的最大分段大小。</p><p><strong>已发送未确认数据大小应该≤接收窗口大小 并且 ≤ 拥塞窗口大小</strong></p><ul><li>慢启动。每次收到一个ACK，cwnd变为原来的2次方，超时则恢复为1</li><li>拥塞避免。每次收到ACK只增加（MSS（MSS/cwnd））</li><li>快速恢复。每次收到冗余ACK只增加MSS</li></ul><p>超时的时候threshold被设置为cwnd/2</p><h3 id="转化关系"><a href="#转化关系" class="headerlink" title="转化关系"></a>转化关系</h3><p><img src="1.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96c6cefd-9e62-4cc9-a60b-578e5c358ab8/Untitled.png"></p><h1 id="网络层（数据层面）"><a href="#网络层（数据层面）" class="headerlink" title="网络层（数据层面）"></a>网络层（数据层面）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>网络层提供两种功能：<ul><li><strong>转发。</strong>当一个分组到达网络层时，网络层应该将它移动到合适的出口。</li><li><strong>路由选择。</strong>决定分组到目的地应该走的路径。</li></ul></li><li>网络层提供一种尽力而为的交付模式</li></ul><h2 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h2><ul><li>路由器匹配时采用<strong>最长前缀匹配原则</strong>从而进行路由选择</li><li>丢包问题<ul><li><strong>输入队列丢包。</strong>不同输入队列的分组准备前往同一个输出队列（交换的速度<strong>没有足够快</strong>），第一个包后面的包将会排队，进而在队列满的时候将会发生丢包。</li><li><strong>输出队列丢包</strong>。如果交换速度<strong>足够快</strong>，多个输入收到的包准备前往相同的输出口，输出队列将会排队，进而发生丢包</li></ul></li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>数据包格式</p><p>版本 首部长度 服务类型 数据包长度</p><p>16位标识         标志位 13位片偏移</p><p>寿命 上层协议 校验和</p><p>源IP</p><p>目的IP</p><ul><li><strong>服务类型</strong>可用来区分实时流量和非实时流量</li><li><strong>标识 标志 片偏移</strong>：数据链路层有MTU最大传输单元，如果IP长度超过MTU，路由器需要将其拆分。（到目的地再被组装）。</li><li><strong>首部校验和</strong>：将首部每两个字节看成一个数，相加的和作为校验和。(TCP的校验和计算整个数据报，而IP的校验和只计算首部)</li><li><strong>上层协议</strong>：目的地根据该字段选择将数据交给哪一层。</li></ul><h2 id="DHCP（动态主机配置协议）"><a href="#DHCP（动态主机配置协议）" class="headerlink" title="DHCP（动态主机配置协议）"></a>DHCP（动态主机配置协议）</h2><p>DHCP是使用UDP进行传递的。</p><ol><li>客户广播一条ICMP查询报文，获取可用的IP地址（源IP为0.0.0.0，目标IP为255.255.255.255）</li><li>ICMP分配一个IP，并生成并广播ICMP响应报文（源IP为服务器IP，目标IP为255.255.255.255）（可能客户所在子网有多个ICMP服务器，所以客户需要选择一个并进行确认）。</li><li>客户端广播一条请求报文，请求将某一IP设置为自己的IP。</li><li>服务端响应ACK报文，客户端将该IP作为自己的IP。</li></ol><h2 id="NAT（本地地址转换）"><a href="#NAT（本地地址转换）" class="headerlink" title="NAT（本地地址转换）"></a>NAT（本地地址转换）</h2><p>路由器维护一个NAT表，分别存储局域网IP：端口和广域网IP：端口的对应关系，在数据包进出的时候对IP进行转换，进而完成使用一个IP地址完成最高6万（取决于端口的数量）个用户的联网工作。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv4对比IPv6</p><ul><li><strong>分片字段被删除。</strong>如果IP分组过大，路由器将向源主机发送一个”分组过大”ICMP报文。分片工作留给源主机完成。</li><li>首部校验和被删除。每次TTL发生变化，都需要重新计算校验和，工作量较大，因此在IPv6中该字段被删除。</li></ul><h1 id="网络层（控制层面）"><a href="#网络层（控制层面）" class="headerlink" title="网络层（控制层面）"></a>网络层（控制层面）</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="链路状态协议（集中式）"><a href="#链路状态协议（集中式）" class="headerlink" title="链路状态协议（集中式）"></a>链路状态协议（集中式）</h3><p>每个节点维护整个子网的链路状态，进而计算出源节点到目标节点的花销，使用Dijkstra算法。</p><h3 id="距离矢量协议（分布式）"><a href="#距离矢量协议（分布式）" class="headerlink" title="距离矢量协议（分布式）"></a>距离矢量协议（分布式）</h3><p>每个节点向直接邻居发送当前到各个节点的最短路径，同时接受邻居的信息并更新，直到自己的各最短路径不再发生变化。</p><h2 id="ICMP（互联网控制信息报文）"><a href="#ICMP（互联网控制信息报文）" class="headerlink" title="ICMP（互联网控制信息报文）"></a>ICMP（互联网控制信息报文）</h2><p>ping和traceroute都使用该报文</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>通过单一信道，将数据从一个节点移动到相邻的节点。</p><h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><ul><li>奇偶校验</li><li>循环冗余校验</li></ul><h2 id="可靠重传"><a href="#可靠重传" class="headerlink" title="可靠重传"></a>可靠重传</h2><p>数据链路层的可靠重传保证了在链路上纠错，而不是传输层或应用层的端到端重传。</p><h2 id="多路访问控制协议"><a href="#多路访问控制协议" class="headerlink" title="多路访问控制协议"></a>多路访问控制协议</h2><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>时分复用 频分复用</p><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>纯ALOHA、时隙ALOHA、CSMA、CSMA/CD</p><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><h2 id="ARP协议-地址解析协议"><a href="#ARP协议-地址解析协议" class="headerlink" title="ARP协议(地址解析协议)"></a>ARP协议(地址解析协议)</h2><p>每个主机上都会维护一个ARP表，里面存储子网内的IP和MAC地址的对应关系。想把数据传递到子网内的下一个节点时，就将目标节点的MAC地址设置为目标MAC地址。</p><p>MAC地址通过查询ARP获取，如果ARP表中不存在，则构造一个ARP分组并在子网内广播。目标主机收到分组之后返回自己的MAC地址。（使用的是MAC广播地址，全是F）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h2 id=&quot;五层网络模型&quot;&gt;&lt;a href=&quot;#五层网络模型&quot; class=&quot;headerlink&quot; title=&quot;五层网络模</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="校招" scheme="https://shaojunying.github.io/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Java中HashMap为什么线程不安全</title>
    <link href="https://shaojunying.github.io/2021/02/07/Java%E4%B8%ADHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"/>
    <id>https://shaojunying.github.io/2021/02/07/Java%E4%B8%ADHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</id>
    <published>2021-02-07T12:57:11.000Z</published>
    <updated>2021-04-04T05:42:02.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的HashMap扩容方法的演变"><a href="#Java中的HashMap扩容方法的演变" class="headerlink" title="Java中的HashMap扩容方法的演变"></a>Java中的HashMap扩容方法的演变</h2><h3 id="Java7及以前"><a href="#Java7及以前" class="headerlink" title="Java7及以前"></a>Java7及以前</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java7之前使用的是头插法，可能在插入时造成环</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="造成环的情况演示"><a href="#造成环的情况演示" class="headerlink" title="造成环的情况演示"></a>造成环的情况演示</h5><p><a href="https://cloud.tencent.com/developer/article/1595438?from=information.detail.hashmap%E5%A4%B4%E6%8F%92%E6%B3%95%E5%B9%B6%E5%8F%91%E6%97%B6%E6%AD%BB%E5%BE%AA%E7%8E%AF">参考链接</a></p><p><strong>造成环的关键代码是<code>Entry&lt;K,V&gt; next = e.next;</code></strong></p><p>图示演示</p><p><img src="hashmap1.png"></p><h3 id="Java8的改进"><a href="#Java8的改进" class="headerlink" title="Java8的改进"></a>Java8的改进</h3><p>从Java8开始,hashmap的头插法被改成了尾插法,从而可以避免形成环.但是,仍然有线程安全问题.</p><ul><li>如果某个桶中没有元素,两个线程同时向桶中put元素,会导致有一个线程put的元素被覆盖掉</li><li>两个进程同时进行size++,也会发生错误</li></ul><p>因此如果想要保证线程安全,还是需要使用ConcurrentHashMap</p><h4 id="Java8中另一个小改进"><a href="#Java8中另一个小改进" class="headerlink" title="Java8中另一个小改进"></a>Java8中另一个小改进</h4><p>不同于Java7中根据hash值重新计算桶的下标,Java8通过hash&amp;cap如果为0说明放在low桶中,如果为1,放在high桶中,减小了计算量</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中的HashMap扩容方法的演变&quot;&gt;&lt;a href=&quot;#Java中的HashMap扩容方法的演变&quot; class=&quot;headerlink&quot; title=&quot;Java中的HashMap扩容方法的演变&quot;&gt;&lt;/a&gt;Java中的HashMap扩容方法的演变&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的虚拟内存</title>
    <link href="https://shaojunying.github.io/2021/01/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>https://shaojunying.github.io/2021/01/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</id>
    <published>2021-01-23T04:12:22.000Z</published>
    <updated>2021-04-04T05:42:02.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟内存的设计目标"><a href="#虚拟内存的设计目标" class="headerlink" title="虚拟内存的设计目标"></a>虚拟内存的设计目标</h2><h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><p>让运行的程序像是拥有整个物理内存,物理内存的管理由操作系统负责</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>操作系统需要保证内存虚拟化在时间和空间上的效率.也即不会导致程序运行太慢,也不会造成太多的内存浪费</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>虚拟内存需要保证不同进程之间互相隔离,从而保证一个进程的崩溃不会影响其他进程.</p><h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>将程序分为固定大小的块,每个块存在不同的区域,使用页表定位一条指令具体的存放位置</p><p>页表中存放虚拟页号 物理页号</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>不容易造成内存浪费,可以将一块较大的区域分割成多个块,分别放置在不同的位置</p><p>需要设置好页大小,不能太大,太大会造成页内部的内存浪费.太小会需要更多的页,造成页表变得很大.</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>将地址空间分成不同的段,比如代码段 堆段 栈段等,可以将不同的段存储在不同的地方.操作系统使用段寄存器保存各个段的基址和大小.</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>将程序划分为逻辑上独立的内存空间,有利于共享和保护</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>首先将程序分为逻辑上独立的段,再将各个段分为大小相同的页.既有了分段对于内存的保护,又有了分页减小内存浪费的特性.</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><h3 id="段页式的缺点"><a href="#段页式的缺点" class="headerlink" title="段页式的缺点"></a>段页式的缺点</h3><ul><li>如果堆比较稀疏,会造成比较严重的内存浪费 </li><li>页表的大小可以为任意值,因此为页表寻找存储空间将变得十分困难.</li></ul><p>因此引出多级页表</p><h3 id="多级页表的访问过程"><a href="#多级页表的访问过程" class="headerlink" title="多级页表的访问过程"></a>多级页表的访问过程</h3><ul><li>访问TLB,如果命中则直接寻址</li><li>TLB没有命中,访问页目录,找到页表的位置</li><li>访问页表,如果存在位为1,定位具体对应的物理地址</li><li>存在位为0,说明页内容存储在磁盘中,需要唤醒操作系统在磁盘中找到相应的信息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;虚拟内存的设计目标&quot;&gt;&lt;a href=&quot;#虚拟内存的设计目标&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存的设计目标&quot;&gt;&lt;/a&gt;虚拟内存的设计目标&lt;/h2&gt;&lt;h3 id=&quot;透明&quot;&gt;&lt;a href=&quot;#透明&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么基于单线程</title>
    <link href="https://shaojunying.github.io/2021/01/21/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <id>https://shaojunying.github.io/2021/01/21/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-01-21T10:05:23.000Z</published>
    <updated>2021-04-04T05:42:02.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis为什么基于单线程"><a href="#redis为什么基于单线程" class="headerlink" title="redis为什么基于单线程"></a>redis为什么基于单线程</h2><ul><li>redis除了数据持久化,主要是内存读写,CPU运算速度不是性能的瓶颈</li><li>基于多线程需要频繁切换进程context,另外线程的互斥也会带来不小开销</li><li>基于IO多路复用redis可以较好地处理客户端传来的命令<h2 id="Redis4-0之后也引入了多线程"><a href="#Redis4-0之后也引入了多线程" class="headerlink" title="Redis4.0之后也引入了多线程"></a>Redis4.0之后也引入了多线程</h2></li></ul><p>多线程可以用来删除规模较大数据.例如del操作可以首先删除key,对于value的释放可以交给另外的线程执行,减少删除大对象带来的开销</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis为什么基于单线程&quot;&gt;&lt;a href=&quot;#redis为什么基于单线程&quot; class=&quot;headerlink&quot; title=&quot;redis为什么基于单线程&quot;&gt;&lt;/a&gt;redis为什么基于单线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;redis除了数据持久化,主要是内存读写</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>IO复用的select poll epoll模型</title>
    <link href="https://shaojunying.github.io/2021/01/21/IO%E5%A4%8D%E7%94%A8%E7%9A%84select-poll-epoll%E6%A8%A1%E5%9E%8B/"/>
    <id>https://shaojunying.github.io/2021/01/21/IO%E5%A4%8D%E7%94%A8%E7%9A%84select-poll-epoll%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-01-21T09:19:54.000Z</published>
    <updated>2021-04-04T05:42:02.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>在调用select之前,需要先将要监听的事件和监听的类型(读完成,写完成,异常)放入指定集合中,之后调用select函数.select函数将会轮询每个事件,最终将满足可读写的事件集合返回</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>由于集合的底层是使用数组实现的,所以大小有限制</strong>. 而现在的服务器需要同时处理大量的IO</li><li><strong>每次执行select操作的时候,都需要将事件集合复制进操作系统集合</strong>. 事件很多时将会比较耗时</li><li><strong>每次select操作都需要轮询所有的fd(文件描述符)</strong>. 也是十分耗时<h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2>poll与select非常类似,他的改进主要是两个方面: </li><li><strong>使用链表代替数组</strong>, 解决了<strong>监听的fd最大长度固定的问题</strong></li><li><strong>使用pollfd</strong>, <strong>避免了每次进行select操作都需要复制所有的fd</strong><br>pollfd的类结构如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pollfd</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events, <span class="comment">// 注册的事件类型</span></span><br><span class="line">    <span class="keyword">short</span> revents <span class="comment">// 实际发生的事件(内核填充)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2>在系统内核中创建一个事件监听表,应用程序直接向内核中添加和删除需要监听的事件,同时提前定义好回调函数,文件读写完成时将直接执行回调函数<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li><li><strong>内核中的事件监听表底层基于B+树</strong>, 解决了<strong>长度有限的问题</strong></li><li><strong>应用程序直接向内核中添加和删除</strong>, 避免了<strong>多次复制造成的开销</strong></li><li><strong>提前定义好回调函数</strong>, 避免了<strong>每次调用select需要遍历所有的事件</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Select&quot;&gt;&lt;a href=&quot;#Select&quot; class=&quot;headerlink&quot; title=&quot;Select&quot;&gt;&lt;/a&gt;Select&lt;/h2&gt;&lt;p&gt;在调用select之前,需要先将要监听的事件和监听的类型(读完成,写完成,异常)放入指定集合中,之后调用se</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="IO" scheme="https://shaojunying.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java 字符串常量池</title>
    <link href="https://shaojunying.github.io/2021/01/21/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>https://shaojunying.github.io/2021/01/21/Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</id>
    <published>2021-01-21T06:23:48.000Z</published>
    <updated>2021-04-04T05:42:02.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="Java6及之前"><a href="#Java6及之前" class="headerlink" title="Java6及之前"></a>Java6及之前</h3><p>字符串常量池存储在永久代中.new String对象需要指向常量池中的字符串</p><h4 id="“1”"><a href="#“1”" class="headerlink" title="“1”"></a>“1”</h4><ul><li>在常量池中创建字符串</li><li>返回其引用<h4 id="new-String-“1”"><a href="#new-String-“1”" class="headerlink" title="new String(“1”)"></a>new String(“1”)</h4></li><li>在常量池中创建字符串</li><li>在堆中创建对象,对象内容指向常量池中的字符串</li><li>返回引用</li></ul><h3 id="Java7及之后"><a href="#Java7及之后" class="headerlink" title="Java7及之后"></a>Java7及之后</h3><p>字符串常量池存储在堆中,常量池可以指向堆中已存在的字符串</p><h4 id="“1”-1"><a href="#“1”-1" class="headerlink" title="“1”"></a>“1”</h4><p>常量池中既可能存储字符串,也可能存储的是字符串的引用</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序1</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>程序1在Java6之前,结果为false, false.在Java7之后结果为false, true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序2</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">s3.intern();</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>程序2在Java7之后仍然为false, false</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;h3 id=&quot;Java6及之前&quot;&gt;&lt;a href=&quot;#Java6及之前&quot; class=&quot;headerlink&quot; title=&quot;Java6及之前&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring MVC获取参数的集中方式</title>
    <link href="https://shaojunying.github.io/2021/01/21/Spring-MVC%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E5%BC%8F/"/>
    <id>https://shaojunying.github.io/2021/01/21/Spring-MVC%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E5%BC%8F/</id>
    <published>2021-01-21T06:09:44.000Z</published>
    <updated>2021-04-04T05:42:02.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-MVC获取Request参数的几种方式"><a href="#Spring-MVC获取Request参数的几种方式" class="headerlink" title="Spring MVC获取Request参数的几种方式"></a>Spring MVC获取Request参数的几种方式</h2><ul><li><p>RequestBody 获取方法体中的参数 不可用于get</p></li><li><p>RequestParam 获取路径中问号后面的数据</p><p>  例子： <a href="http://www.baidu.com/?id">http://www.baidu.com?</a>keyword=1, 可以用来获取keyword参数</p></li><li><p>PathVariable 获取路径中的数据</p><p>  例子： <a href="http://www.baidu.com/%7Bid%7D">http://www.baidu.com/{id}</a> , 可以获取id参数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-MVC获取Request参数的几种方式&quot;&gt;&lt;a href=&quot;#Spring-MVC获取Request参数的几种方式&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC获取Request参数的几种方式&quot;&gt;&lt;/a&gt;Spring M</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://shaojunying.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Spring MVC" scheme="https://shaojunying.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Get和Post cookie和session区别</title>
    <link href="https://shaojunying.github.io/2021/01/21/Get%E5%92%8CPost-cookie%E5%92%8Csession%E5%8C%BA%E5%88%AB/"/>
    <id>https://shaojunying.github.io/2021/01/21/Get%E5%92%8CPost-cookie%E5%92%8Csession%E5%8C%BA%E5%88%AB/</id>
    <published>2021-01-21T06:09:02.000Z</published>
    <updated>2021-04-04T05:42:02.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h1><ul><li>Get是从服务端请求资源,而post是向服务端发送资源</li><li>Get的参数附在URL后面,Post是存储在消息主体中,相对来说Post更安全一些</li><li>Get的的URL有最大长度限制,也就导致了传输的数据不能过大</li></ul><h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><ul><li>Cookie保存在客户端,Session保存在服务端</li><li>Session比较难以支持分布式,因为一个服务器不知道另一个服务器中存的session</li><li>Cookie不能存储敏感的信息,否则会不安全</li><li>Session会增加服务器的内存压力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Get和Post区别&quot;&gt;&lt;a href=&quot;#Get和Post区别&quot; class=&quot;headerlink&quot; title=&quot;Get和Post区别&quot;&gt;&lt;/a&gt;Get和Post区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Get是从服务端请求资源,而post是向服务端发送资源&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="网页开发" scheme="https://shaojunying.github.io/tags/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>进程通信的几种方式</title>
    <link href="https://shaojunying.github.io/2021/01/21/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://shaojunying.github.io/2021/01/21/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2021-01-21T06:08:05.000Z</published>
    <updated>2021-04-04T05:42:02.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="低级方式"><a href="#低级方式" class="headerlink" title="低级方式"></a>低级方式</h2><ul><li>PV操作：用来解决互斥和同步问题</li></ul><h2 id="高级方式"><a href="#高级方式" class="headerlink" title="高级方式"></a>高级方式</h2><ul><li>共享存储：两个进程共享同一片内存区域，都可以读写这篇内存，需要使用进行互斥控制</li><li>消息传递：包含直接通信和间接通信两种方式<ul><li>直接通信：发送方直接将消息发送到接收者的缓冲消息队列中</li><li>间接通信：发送方将消息发送到一个中介中，类似于信箱，接收者从信箱中获取最新消息</li></ul></li><li>管道通信：（消息传递的特殊形式，也是共享内存的优化和发展）<ul><li>管道长度固定，满了之后写操作被阻塞，空了之后读操作被阻塞</li><li>半双工通信，所以要想实现两方随意传输消息需要使用两个管道</li><li>接收者取出数据之后数据即被抛弃，不可再次获取</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;低级方式&quot;&gt;&lt;a href=&quot;#低级方式&quot; class=&quot;headerlink&quot; title=&quot;低级方式&quot;&gt;&lt;/a&gt;低级方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PV操作：用来解决互斥和同步问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;高级方式&quot;&gt;&lt;a href=&quot;#高级方式</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java中的BIO NIO AIO</title>
    <link href="https://shaojunying.github.io/2021/01/21/Java%E4%B8%AD%E7%9A%84BIO-NIO-AIO/"/>
    <id>https://shaojunying.github.io/2021/01/21/Java%E4%B8%AD%E7%9A%84BIO-NIO-AIO/</id>
    <published>2021-01-21T06:06:22.000Z</published>
    <updated>2021-04-04T05:42:02.630Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://developer.aliyun.com/article/726698">https://developer.aliyun.com/article/726698</a></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>BIO: 同步阻塞IO</li><li>NIO: 同步非阻塞IO</li><li>AIO: 异步非阻塞IO</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>IO操作分为两步: 发起IO和实际的IO操作. 其中同步和异步区别在于第二步,若</p><ul><li>同步: 实际IO操作阻塞、(发起IO之后需要等待或者轮询,直到IO执行完毕,之后才能执行后续操作),-</li><li>异步：发起IO之后不阻塞、(后续操作不受影响,只是在操作系统通知IO就绪之后才执行后续IO操作)</li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>区别在发起IO这一步</p><ul><li>阻塞：发起IO之后阻塞,一直等待IO完成</li><li>非阻塞：发起IO之后不会一直等待，为非阻塞IO</li></ul><h2 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h2><h3 id="BIO（同步阻塞IO）"><a href="#BIO（同步阻塞IO）" class="headerlink" title="BIO（同步阻塞IO）"></a>BIO（同步阻塞IO）</h3><p>发起IO之后一直等待，直到IO准备就绪，进行后续的IO操作</p><h3 id="NIO（同步非阻塞IO）"><a href="#NIO（同步非阻塞IO）" class="headerlink" title="NIO（同步非阻塞IO）"></a>NIO（同步非阻塞IO）</h3><p>发起IO之后会立刻收到一个状态值，标识IO是否准备就绪，如果没有就绪则一直循环</p><p>（NIO中使用Selector来同时轮询多个Channel上的事件，避免线程切换的开销）</p><h3 id="AIO（异步阻塞IO）"><a href="#AIO（异步阻塞IO）" class="headerlink" title="AIO（异步阻塞IO）"></a>AIO（异步阻塞IO）</h3><p>发起IO之后继续执行后续操作，定义好回调函数，在IO操作执行完毕之后将会主动调用该回调函数</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>,<span class="number">9999</span>), <span class="number">50</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 轮询</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 收到新的channel事件</span></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 连接请求</span></span><br><span class="line">                    ServerSocketChannel serverSocketChannel1 = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel1.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到一条新请求&quot;</span>);</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">200</span>);</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.out.println(buffer.toString());</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> AioServer(<span class="number">9999</span>)).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        AsynchronousChannelGroup group;</span><br><span class="line">        AsynchronousServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">        AioServer(<span class="keyword">int</span> port)&#123;</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                ExecutorService executor;</span><br><span class="line">                group = AsynchronousChannelGroup.withCachedThreadPool(</span><br><span class="line">                        Executors.newCachedThreadPool(), <span class="number">5</span>);</span><br><span class="line">                serverSocketChannel = AsynchronousServerSocketChannel.open(group);</span><br><span class="line">                serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            serverSocketChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">AioServer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, AioServer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 继续接收下一个请求，构成循环调用</span></span><br><span class="line">            attachment.serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到连接请求：&quot;</span> + result.getRemoteAddress().toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AioServer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.aliyun.com/article/726698&quot;&gt;https://developer.aliyun.com/article/726698&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="IO" scheme="https://shaojunying.github.io/tags/IO/"/>
    
    <category term="面试" scheme="https://shaojunying.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM的体系结构</title>
    <link href="https://shaojunying.github.io/2020/12/04/JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://shaojunying.github.io/2020/12/04/JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-12-04T06:16:45.000Z</published>
    <updated>2021-04-04T05:42:02.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><p>JVM的体系结构如上图所示，其中方法区和堆是线程共享的，垃圾回收主要就是在这两个区域上进行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;JVM的体系结构如上图所示，其中方法区和堆是线程共</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快速排序的几种实现</title>
    <link href="https://shaojunying.github.io/2020/11/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shaojunying.github.io/2020/11/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-11-17T11:45:41.000Z</published>
    <updated>2021-04-04T05:42:02.668Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一路快排"><a href="#一路快排" class="headerlink" title="一路快排"></a>一路快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleWayQuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">        sort(nums, l, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="comment">// i 指向最后一个小于pivot的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l + <span class="number">1</span>; j &lt;= r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot)&#123;</span><br><span class="line">                swap(nums, ++i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, l);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二路快排"><a href="#二路快排" class="headerlink" title="二路快排"></a>二路快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">        sort(nums, l, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="comment">// [l, i] 小于等于, [j+1,r] 大于</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i + <span class="number">1</span>] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(nums, i + <span class="number">1</span>, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i+1 第一个大于 j 第一个小于</span></span><br><span class="line">        swap(nums, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int i = l + 1, j = r;</span></span><br><span class="line"><span class="comment">//        // [l,i-1] 小于等于 [j+1,r]大于</span></span><br><span class="line"><span class="comment">//        while (i &lt;= j)&#123;</span></span><br><span class="line"><span class="comment">//            while (i &lt;= j &amp;&amp; nums[i] &lt;= pivot)&#123;</span></span><br><span class="line"><span class="comment">//                i ++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            while (i &lt;= j &amp;&amp; nums[j] &gt;= pivot)&#123;</span></span><br><span class="line"><span class="comment">//                j --;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt;= j)&#123;</span></span><br><span class="line"><span class="comment">//                swap(nums, i, j);</span></span><br><span class="line"><span class="comment">//                i ++;</span></span><br><span class="line"><span class="comment">//                j --;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // i 第一个大于 j 第一个小于</span></span><br><span class="line"><span class="comment">//        swap(nums, l, j);</span></span><br><span class="line"><span class="comment">//        return j;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a>三路快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">        sort(nums, l, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="comment">// [l, i] 小于等于, [j+1,r] 大于</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i + <span class="number">1</span>] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(nums, i + <span class="number">1</span>, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i+1 第一个大于 j 第一个小于</span></span><br><span class="line">        swap(nums, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int i = l + 1, j = r;</span></span><br><span class="line"><span class="comment">//        // [l,i-1] 小于等于 [j+1,r]大于</span></span><br><span class="line"><span class="comment">//        while (i &lt;= j)&#123;</span></span><br><span class="line"><span class="comment">//            while (i &lt;= j &amp;&amp; nums[i] &lt;= pivot)&#123;</span></span><br><span class="line"><span class="comment">//                i ++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            while (i &lt;= j &amp;&amp; nums[j] &gt;= pivot)&#123;</span></span><br><span class="line"><span class="comment">//                j --;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt;= j)&#123;</span></span><br><span class="line"><span class="comment">//                swap(nums, i, j);</span></span><br><span class="line"><span class="comment">//                i ++;</span></span><br><span class="line"><span class="comment">//                j --;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // i 第一个大于 j 第一个小于</span></span><br><span class="line"><span class="comment">//        swap(nums, l, j);</span></span><br><span class="line"><span class="comment">//        return j;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一路快排&quot;&gt;&lt;a href=&quot;#一路快排&quot; class=&quot;headerlink&quot; title=&quot;一路快排&quot;&gt;&lt;/a&gt;一路快排&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    
    <category term="算法" scheme="https://shaojunying.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://shaojunying.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 121. 买卖股票的最佳时机</title>
    <link href="https://shaojunying.github.io/2020/11/08/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://shaojunying.github.io/2020/11/08/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-11-08T03:36:53.000Z</published>
    <updated>2021-04-04T05:42:02.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1(动态规划)"></a>解法1(动态规划)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>memo[i][0] 第i天的最低购买价格,</li><li>memo[i][1] 第i天的最大利润(不一定第i天卖出,可能是从0到i之间任意一天卖出)</li><li><code>memo[i][0] = min(memo[i-1][0], prices[i])</code></li><li><code>memo[i][1] = max(memo[i-1][1], prices[i]-memo[i-1][0])</code></li><li>memo[len-1][1]就是最后一天的最大利润</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memo[i][0] 第i天的最低购买价格</span></span><br><span class="line">        <span class="comment">// memo[i][1] 第i天的最大利润</span></span><br><span class="line">        <span class="comment">// memo[i][0] = min(memo[i-1][0], prices[i])</span></span><br><span class="line">        <span class="comment">// memo[i][1] = max(memo[i-1][1], prices[i]-memo[i-1][0])</span></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        memo[<span class="number">0</span>][<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// memo[0][1] = 0;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; memo.length; i++)&#123;</span><br><span class="line">            memo[i][<span class="number">0</span>] = Math.min(memo[i-<span class="number">1</span>][<span class="number">0</span>], prices[i]);</span><br><span class="line">            memo[i][<span class="number">1</span>] = Math.max(memo[i-<span class="number">1</span>][<span class="number">1</span>], prices[i]-memo[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[memo.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法2-动态规划"><a href="#解法2-动态规划" class="headerlink" title="解法2(动态规划)"></a>解法2(动态规划)</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>memo[i][0] 第i天的最低购买价格</li><li><code>memo[i][0] = min(memo[i-1][0], prices[i])</code></li><li>prices[i] - memo[i][0]表示第i天卖出可以获得的最大利润</li><li>最后需要遍历一遍,因为不能确定哪一天卖出能获得最大利润.</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memo[i][0] 第i天的最低购买价格</span></span><br><span class="line">        <span class="comment">// memo[i][0] = min(memo[i-1][0], prices[i])</span></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>][<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// memo[0][1] = 0;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; memo.length; i++)&#123;</span><br><span class="line">            memo[i][<span class="number">0</span>] = Math.min(memo[i-<span class="number">1</span>][<span class="number">0</span>], prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++)&#123;</span><br><span class="line">            max = Math.max(prices[i]-memo[i][<span class="number">0</span>], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法3-动态规划-解法2的变种"><a href="#解法3-动态规划-解法2的变种" class="headerlink" title="解法3(动态规划,解法2的变种)"></a>解法3(动态规划,解法2的变种)</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面是记录每天的可以持有的最低价格,下面换种思路,保存每天假如卖出的话的最大利润</p><ul><li><code>nums[i]=prices[i]-prices[i-1]</code> 第i-1天的买入,第i天卖出的最大利润</li><li><code>nums[j]+nums[j+1]+...+nums[i]</code>表示第j-1天买入,第i天卖出的最大利润</li><li>memo[i]表示以i结尾的最大连续子数组的和(第i天卖出股票的最大利润)</li><li><code>memo[i] = max(memo[i-1]+nums[i], 0)</code><ul><li>case1: 第i-1天不卖,改为第i天卖出股票</li><li>case2: 第i天不买也不卖,没有利润</li></ul></li><li>(这里的memo[i]相当于上面的prices[i]-memo[i][0])</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memo[i] ==&gt; 以i结尾的连续子数组的最大和</span></span><br><span class="line">        <span class="comment">// memo[i] = max(memo[i-1]+nums[i], 0);</span></span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            memo[i] = Math.max(memo[i-<span class="number">1</span>] + nums[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++)&#123;</span><br><span class="line">            max = Math.max(memo[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法4-分治法"><a href="#解法4-分治法" class="headerlink" title="解法4(分治法)"></a>解法4(分治法)</h2><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分治法 求 nums的最大连续子数组的和</span></span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [start, end]</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">int</span> sum = nums[mid];</span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = maxSum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt; start -<span class="number">1</span>; i --)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxSum, Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解法1-动态规划&quot;&gt;&lt;a href=&quot;#解法1-动态规划&quot; class=&quot;headerlink&quot; title=&quot;解法1(动态规划)&quot;&gt;&lt;/a&gt;解法1(动态规划)&lt;/h2&gt;&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="https://shaojunying.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="分治法" scheme="https://shaojunying.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中Map的学习</title>
    <link href="https://shaojunying.github.io/2020/11/03/Java%E4%B8%ADMap%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/11/03/Java%E4%B8%ADMap%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-03T11:48:21.000Z</published>
    <updated>2021-04-04T05:42:02.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h3><ul><li>默认初始容量为16,负载因子为0.75</li><li>如果key为空,那么hash值直接为0</li><li>计算hash数组下标的算法:<ul><li>将hash值右移16位 ^(异或) hash</li><li>将得到的值与(capacity-1)取与</li></ul></li><li>默认情况下,总结点数大于64时<ul><li>数组中某链表长度大于8时,链表会被转化为红黑树</li><li>当长度小于等于6时,红黑树会被转化为链表</li></ul></li></ul><h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>HashMap为线程安全的,而HashTable为线程不安全的,但是效率较高</p><h3 id="父类不同"><a href="#父类不同" class="headerlink" title="父类不同"></a>父类不同</h3><p>HashMap继承自AbstractMap,HashTable继承自Dictionary</p><h3 id="对null的支持不同"><a href="#对null的支持不同" class="headerlink" title="对null的支持不同"></a>对null的支持不同</h3><p>前者支持null为key,后者不支持</p><h3 id="数组索引的计算方式不同"><a href="#数组索引的计算方式不同" class="headerlink" title="数组索引的计算方式不同"></a>数组索引的计算方式不同</h3><ul><li>HashMap<ul><li>hash值右移16位之后与原hash值取异或,之后再对(capacity-1)取与</li><li>capacity大小总是2的次幂</li></ul></li><li>HashTable<ul><li>去掉符号位的剩下31位对capacity取余作为数组索引</li></ul></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>HashMap和LinkedHashMap允许key为null</li><li>TreeMap的key不允许为null</li><li>ConcurrentHashMap的key和value都不允许为null</li></ul><h2 id="对HashMap的分析"><a href="#对HashMap的分析" class="headerlink" title="对HashMap的分析"></a>对HashMap的分析</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 表为null或者里面没有元素</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 没有发生碰撞</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发生碰撞</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// p.key 和 key 相等</span></span><br><span class="line">            <span class="comment">// 之后将新value赋值到e上</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 红黑树 ==&gt; 将新元素插入红黑树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 链表 ==&gt; 将新元素插入到链表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// p是最后一个节点,新元素应该插入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 插入之后超过threshold ==&gt; 将链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在链表中找到key相等的节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用新value覆盖原来的旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 空函数</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入成功新结点</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 空函数</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧表为空</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧表不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 容量大于最大容量了 ==&gt; 不扩容了 ==&gt; 直接返回</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//扩容之后的容量小于最大容量 and 旧容量大于默认初始容量</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 初始容量被保存在旧 threshold 中</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧表不为空,将旧表的元素复制到新表上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 坐标为j的地方存在元素</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 只有一个元素</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;h3 id=&quot;一些属性&quot;&gt;&lt;a href=&quot;#一些属性&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="集合类" scheme="https://shaojunying.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList的学习</title>
    <link href="https://shaojunying.github.io/2020/11/03/CopyOnWriteArrayList%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/11/03/CopyOnWriteArrayList%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-03T07:18:10.000Z</published>
    <updated>2021-04-04T05:42:02.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>写时复制</code>:多个调用者同时请求相同资源,那么他们会使用相同的指针指向相同的资源,直到有个调用者要修改该资源时,系统才会为该调用者复制一份专属资源.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>CopyOnWriteArrayList底层也是基于数组实现的,与ArrayList类似.</li><li>增删改(add,remove,clear,set)会首先加一个锁(不是方法锁,是对一个变量加锁),将原来的数组复制一份,后续的操作都作用在新数组上,之后将数组指针指向新数组.</li><li>迭代:迭代不用加锁,首先会保存当前数组的指针,之后的操作都是在该数组上进行,不受后续的更新操作的影响.</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>内存占用大:每次更新都要复制一个新数组,如果更新较频繁,则需要多次复制数组.</li><li>只能保证最终一致性,不能保证实时一致性:如果在一个线程迭代过程中另一个线程修改数组,该更新不会体现在迭代上(迭代一直在原数组上进行).</li></ul><h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><p>CopyOnWriteArraySet也是基于CopyOnWriteArrayList的,只是在add时首先判断list中是否存在该元素.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;写时复制&lt;/code&gt;:多个调用者同时请求相同资源,那么他们会使用相同的指针指向相同的资源,直到有个调用者要修改该资源时,系统才</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="集合类" scheme="https://shaojunying.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    <category term="并发" scheme="https://shaojunying.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中集合类的学习</title>
    <link href="https://shaojunying.github.io/2020/11/03/Java%E4%B8%AD%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/11/03/Java%E4%B8%AD%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-03T05:57:22.000Z</published>
    <updated>2021-04-04T05:42:02.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collection的各个实现类"><a href="#Collection的各个实现类" class="headerlink" title="Collection的各个实现类"></a>Collection的各个实现类</h2><a id="more"></a><p><img src="Collection.png"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List的实现类有三个，分别是ArrayList、LinkedList、Vector</p><p>元素可以为null</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li><p>ArrayList底层是数组，进行增删时需要调用naive方法进行拷贝复制</p></li><li><p>ArrayList初始容量为10，每次扩容先扩容为原来的1.5倍，如果仍然不够，就直接将容量设置为目标容量。</p></li></ul><h4 id="线程安全的ArrayList"><a href="#线程安全的ArrayList" class="headerlink" title="线程安全的ArrayList"></a>线程安全的ArrayList</h4><p>要使用线程安全的ArrayList，可以使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>,之后list的每个方法都是在原来的ArrayList外加了一个锁,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.hashCode();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>阅读源码可知,在遍历list时,需要自己通过如下方式加锁(list.iterator()没有进行任何并发处理)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">    Iterator i = list.iterator(); <span class="comment">// Must be in synchronized block</span></span><br><span class="line">    <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">        foo(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>LinkedList底层是双向链表</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector是线程安全的，但是现在已经很少用了。原因：</p><ul><li>所有方法都被synchronized修饰，效率较低</li><li>每次扩容扩容为原来的2倍，较耗费内存</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>ArrayList在尾部增删元素不需要移动元素，效率比较高，如果需要随机在任意位置增删元素，则应该选择LinkedList</p></li><li><p>LinkedList主要用于实现队列和栈</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Collection的各个实现类&quot;&gt;&lt;a href=&quot;#Collection的各个实现类&quot; class=&quot;headerlink&quot; title=&quot;Collection的各个实现类&quot;&gt;&lt;/a&gt;Collection的各个实现类&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="集合类" scheme="https://shaojunying.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis的五种对象使用的数据结构</title>
    <link href="https://shaojunying.github.io/2020/11/02/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://shaojunying.github.io/2020/11/02/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-11-02T13:03:40.000Z</published>
    <updated>2021-04-04T05:42:02.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串(SDS)"></a>简单动态字符串(SDS)</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>len:长度(字符数组中已使用的字节数)</li><li>free:未使用的字节数</li><li>buf: 分配的子节数组</li></ul><h3 id="几个注意事项"><a href="#几个注意事项" class="headerlink" title="几个注意事项"></a>几个注意事项</h3><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>在为SDS分配空间时,如果其占用空间小于1M,就为其分配需要空间的2倍,否则就在需要的空间之外额外分配1M</p><h4 id="惰性释放"><a href="#惰性释放" class="headerlink" title="惰性释放"></a>惰性释放</h4><p>SDS不会立即回收缩短之后多出来的字节</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>不同于c字符串使用’\0’字符来计算字符串的长度,SDS使用字段len,从而可以存储二进制数据,例如图片…</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>无环</li><li>双向</li><li>包含头尾节点</li><li>带有长度</li></ul><h2 id="对象使用的基本数据结构"><a href="#对象使用的基本数据结构" class="headerlink" title="对象使用的基本数据结构"></a>对象使用的基本数据结构</h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><ul><li>整数</li><li>embstr简单动态字符串(简化的SDS)</li><li>简单动态祖父穿</li></ul><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><ul><li>压缩列表</li><li>双向链表</li></ul><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><ul><li>压缩列表</li><li>字典(key存储值,value为null)</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>整数集合</li><li>字典</li></ul><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><ul><li>压缩列表</li><li>跳跃表+字典<ul><li>跳跃表用来实现范围查询</li><li>字典用于对象到分数的映射</li></ul></li></ul><h2 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h2><p>对象中有一个字段lru用来记录该对象最后一次被访问的时间</p><p>lru值越小，说明空转时间越长，如果服务端开启了maxmemory，redis在内存超过max_memory时,删除空转时间最长的键</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单动态字符串-SDS&quot;&gt;&lt;a href=&quot;#简单动态字符串-SDS&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串(SDS)&quot;&gt;&lt;/a&gt;简单动态字符串(SDS)&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 349. 两个数组的交集</title>
    <link href="https://shaojunying.github.io/2020/11/02/LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>https://shaojunying.github.io/2020/11/02/LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T09:18:33.000Z</published>
    <updated>2021-04-04T05:42:02.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>两轮遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    set.add(nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : set) &#123;</span><br><span class="line">            ans[i++] = integer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>使用hash表存储nums1中出现的元素，之后遍历nums2，将重复出现的添加到结果集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(num))&#123;</span><br><span class="line">                set.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set)&#123;</span><br><span class="line">            ans[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h1><p>使用两个hash表存储，之后取两个hash表的交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &lt; set2.size())&#123;</span><br><span class="line">            Set&lt;Integer&gt; temp = set1;</span><br><span class="line">            set1 = set2;</span><br><span class="line">            set2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(num))&#123;</span><br><span class="line">                set.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set)&#123;</span><br><span class="line">            ans[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h1><p>排序两个数组,之后使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j])&#123;</span><br><span class="line">                set.add(nums1[i]);</span><br><span class="line">                i ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set)&#123;</span><br><span class="line">            ans[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法5"><a href="#解法5" class="headerlink" title="解法5"></a>解法5</h1><p>排序一个数组,之后二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = nums1.length;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="comment">// [left, right)</span></span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums1[mid] == num)&#123;</span><br><span class="line">                    set.add(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[mid] &lt; num)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set)&#123;</span><br><span class="line">            ans[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解法1&quot;&gt;&lt;a href=&quot;#解法1&quot; class=&quot;headerlink&quot; title=&quot;解法1&quot;&gt;&lt;/a&gt;解法1&lt;/h1&gt;&lt;p&gt;两轮遍历&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
    <category term="双指针" scheme="https://shaojunying.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="https://shaojunying.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="二分查找" scheme="https://shaojunying.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的跳跃表</title>
    <link href="https://shaojunying.github.io/2020/10/28/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://shaojunying.github.io/2020/10/28/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8/</id>
    <published>2020-10-28T08:54:53.000Z</published>
    <updated>2021-04-04T05:42:02.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis中跳跃表的实现"><a href="#Redis中跳跃表的实现" class="headerlink" title="Redis中跳跃表的实现"></a>Redis中跳跃表的实现</h2><p>Redis中跳跃表的实现类时zskiplist,每个节点的实现是zskiplistnode.</p><h3 id="z-skip-list-node的实现"><a href="#z-skip-list-node的实现" class="headerlink" title="z_skip_list_node的实现"></a>z_skip_list_node的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistnode</span>&#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        zskiplistnode * forward;</span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">int</span> span;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    zskiplistnode * back;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例对象</span></span><br><span class="line">    robj * obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳跃表的节点如上所示</p><h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>跳跃表节点的level数组可以包含多个元素,每个元素都包含一个只想其他节点的指针,从而加快查找速度.</p><p>一般来说,层数越大,查询速度越快.</p><p>层数大小是通过幂次定律(值越大出现的概率越小)来从1-32随机取值的.</p><h5 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h5><p>level数组中每个元素都包含一个前进指针和跨度,前进指针指向后面的节点,而跨度则记录两个节点之间的距离</p><p>前进指针用来从前向后访问节点的.可以通过一直使用跨度为1的前进指针来遍历整个跳跃表.</p><h5 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h5><p>指向null的前进指针的跨度为0</p><p>遍历到指定节点路程上的跨度之和即为该节点的排位</p><h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>后退指针用来从后向前访问节点的,可以用来从后向前遍历整个跳跃表.</p><p>后退指针只能逐个访问节点,不像前进指针可以一次跳过多个节点.</p><h4 id="分值和成员对象"><a href="#分值和成员对象" class="headerlink" title="分值和成员对象"></a>分值和成员对象</h4><p>所有节点按照分值从小到达排序,如果分值相同,则按照成员对象的字典序排序</p><p>每个节点的成员对象必须唯一,而分值可以相同</p><h3 id="z-skip-list实现"><a href="#z-skip-list实现" class="headerlink" title="z_skip_list实现"></a>z_skip_list实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistnode</span> * <span class="title">head</span>, <span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点总数量</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有层的层数最大值(不包括空的表头结点)</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示是跳跃表的结构,其中head指向空的头节点,tail则指向尾节点.</p><p>跳跃表中包含一个空的头,每次查询都是从空的头节点开始的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis中跳跃表的实现&quot;&gt;&lt;a href=&quot;#Redis中跳跃表的实现&quot; class=&quot;headerlink&quot; title=&quot;Redis中跳跃表的实现&quot;&gt;&lt;/a&gt;Redis中跳跃表的实现&lt;/h2&gt;&lt;p&gt;Redis中跳跃表的实现类时zskiplist,每个节点的实</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Stack</title>
    <link href="https://shaojunying.github.io/2020/10/28/Java%E4%B8%AD%E7%9A%84Stack/"/>
    <id>https://shaojunying.github.io/2020/10/28/Java%E4%B8%AD%E7%9A%84Stack/</id>
    <published>2020-10-28T07:37:35.000Z</published>
    <updated>2021-04-04T05:42:02.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自刘宇波老师的<a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&mid=2247485646&idx=1&sn=044c6359c49f65935333e6e6c6366f91">Java 程序员，别用 Stack？！</a>,是对于这篇文章的学习总结</p></blockquote><h2 id="Java中Stack的问题"><a href="#Java中Stack的问题" class="headerlink" title="Java中Stack的问题"></a>Java中Stack的问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">//..</span></span><br></pre></td></tr></table></figure><p>如上是Java中Stack的源码,通过阅读源码可知,Stack继承自Vector,Vector是一个动态数组,如下是Vector源码的一部分.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; // <span class="title">xxx</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        insertElementAt(element, index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读源码可知,Vector有一个函数<code>void add(int index, E element)</code>,该函数可以在数组的任意位置添加一个元素,而Stack是继承Vector的,所以Stack也可以调用<code>void add(int index, E element)</code>在栈中任意位置添加元素.而这个操作显然不合理.</p><h2 id="Java官方推荐实现"><a href="#Java官方推荐实现" class="headerlink" title="Java官方推荐实现"></a>Java官方推荐实现</h2><p>在Stack的Doc注释中可以看到这样一段话,</p><blockquote><p>A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:</p></blockquote><p><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></p><p>如上,Java推荐使用双端队列Deque实现栈,使用双端队列可以避免原来栈可以在任意位置插入元素的情况.</p><p>但是双端队列可以在队列两端进行插入和删除,而栈应该只能在一段进行,因此该实现仍有缺陷,因为可以调用<code>stack.remove</code>删除栈底的元素</p><h2 id="最优实现"><a href="#最优实现" class="headerlink" title="最优实现"></a>最优实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;</span><br><span class="line">        deque.addFirst(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是最优实现,底层使用Deque实现,但是对外只暴露push,pop等修改操作,保证了只能从一端操作栈.</p><h2 id="为什么使用ArrayDeque而不是LinkedList作为Deque的底层实现"><a href="#为什么使用ArrayDeque而不是LinkedList作为Deque的底层实现" class="headerlink" title="为什么使用ArrayDeque而不是LinkedList作为Deque的底层实现"></a>为什么使用ArrayDeque而不是LinkedList作为Deque的底层实现</h2><p>ArrayDeque底层基于动态数组,动态数组在触发扩容时复杂度时O(n),平均复杂度是O(1),LinkedList底层是基于链表的,平均复杂度为O(1),但是每次修改都需要申请、释放节点,导致在数据规模较大时,链表要比动态数组慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            stack1.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            stack2.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是一段测试代码,输出结果如下,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4808</span><br><span class="line">6688</span><br></pre></td></tr></table></figure><p>可以看到,向栈中压入1000万条数据时,ArrayDeque用时4808毫秒,而LinkedList用时6688.因此应该使用ArrayDeque作为Deque的底层实现.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考自刘宇波老师的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&amp;mid=2247485646&amp;idx=1&amp;sn=044c6359c49f65935333e6e6c6366f</summary>
      
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="数据结构" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的字典</title>
    <link href="https://shaojunying.github.io/2020/10/27/Redis%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shaojunying.github.io/2020/10/27/Redis%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-27T06:32:28.000Z</published>
    <updated>2021-04-04T05:42:02.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>字典的底层是基于哈希表实现的,哈希表中的每一个节点保存了字典的一个键值对</p><h3 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 数组,存储哈希表中的节点</span></span><br><span class="line">    dictEntry ** table;</span><br><span class="line">    <span class="comment">// 数组的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 掩码 用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表的结构如上所示,其中数组table中的每一项对应哈希表中的一个节点.sizemask的值总是size的值减1,这个属性和哈希值一起决定了新节点应该放在table的哪个地方.</p><h3 id="哈希表节点的实现"><a href="#哈希表节点的实现" class="headerlink" title="哈希表节点的实现"></a>哈希表节点的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">// 当前的键</span></span><br><span class="line">    <span class="keyword">void</span> * key;</span><br><span class="line">    <span class="comment">// 当前的值</span></span><br><span class="line">    <span class="keyword">union</span>(</span><br><span class="line">        <span class="keyword">void</span> * val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64</span><br><span class="line">    ) v;</span><br><span class="line">    <span class="comment">// 存储下一个节点的指针</span></span><br><span class="line">    dictEntry * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是哈希表节点的实现,其中key是键值对的键,v是键值对的值,next指向另一个哈希表节点的指针,用于解决哈希冲突.</p><h3 id="字典的实现-1"><a href="#字典的实现-1" class="headerlink" title="字典的实现"></a>字典的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType * type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> * privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash进度</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是字典的数据结构</p><ul><li>类型特定函数<code>type</code>中存储一些指针类型对应的函数实现,例如<code>计算哈希值</code>, <code>复制节点</code>….</li><li><code>privdata</code>存储要传给类型特定函数的可选参数</li><li>哈希表<code>ht</code>存储两个哈希表,一般只使用ht[0],只有在对ht[0]进行rehash时才会使用ht[1]</li><li>rehash进度<code>trehashidx</code>记录当前rehash的进度,没有进行rehash操作时该变量为-1.</li></ul><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>找节点在哈希表中位置的过程如下</p><ol><li>使用类型特定函数计算节点的hash值<code>hash = dict-&gt;type-&gt;hashFunction</code></li><li>将hash值与掩码取余获得索引值<code>index = hash &amp; dict-&gt;ht[0]-&gt;sizemask</code></li></ol><h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>多个哈希节点使用next指针构成一个链表,遇到冲突时,即向链表中添加节点即可.</p><p><em>由于哈希表没有保存链表的尾节点,所以每次添加新结点都是添加在链表的头部.</em></p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><h3 id="rehash的步骤"><a href="#rehash的步骤" class="headerlink" title="rehash的步骤"></a>rehash的步骤</h3><ol><li>为ht[1]分配空间<ul><li>如果是扩展,那么新容量为第一个大于等于<code>dict-&gt;ht[0].used*2</code>的2的n次方</li><li>如果是收缩,那么新容量为第一个大于等于<code>dict-&gt;ht[0].used</code>的2的n次方</li></ul></li><li>为<code>dict-&gt;ht[0]</code>中元素重新计算hash值,将其移动到dict[1]上.</li><li>移动完毕之后销毁ht[0]的空间,将ht[0]指向ht[1]所在空间,在ht[1]上创建一个空哈希表,为下一次hash做准备.</li></ol><h3 id="rehash的时机"><a href="#rehash的时机" class="headerlink" title="rehash的时机"></a>rehash的时机</h3><ul><li>扩展<ul><li>如果此时正在进行bgsave或者bg_rewrite_aof,且装载因子大于等于5</li><li>如果没有进行上述操作,装载因子大于等于1</li></ul></li><li>收缩<ul><li>装载因子小于0.1</li></ul></li></ul><h4 id="bg-xxx时装载因子大于等于5才保存的原因"><a href="#bg-xxx时装载因子大于等于5才保存的原因" class="headerlink" title="bg_xxx时装载因子大于等于5才保存的原因"></a>bg_xxx时装载因子大于等于5才保存的原因</h4><p>大多数操作系统都采用<code>写时复制</code>的策略来提高子进程的效率,为了减少内存的读写,最大限度节约内存.</p><p><code>写时复制</code>:在创建子进程之后,父子进程共用同一片内存区域,只有父子进程有一方要对内存中内容做修改时才复制内存区域的内容.</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>rehash动作不是一次性完成的,而是分多次、渐进式进行的.通过这种方式将计算量均摊到每次对字典进行增删改查的操作上，避免了集中进行rehas的工作量。</p><h3 id="渐进式rehash的步骤"><a href="#渐进式rehash的步骤" class="headerlink" title="渐进式rehash的步骤"></a>渐进式rehash的步骤</h3><ol><li>为ht[1]分配空间，使字典同时持有两个哈希表。</li><li>将trehashidx置为0，rehash工作正式开始</li><li>每次对字典进行增删改查时，除了执行对应操作外，还会将trehashidx索引上的节点rehash到ht[1]上，并将trehashidx加1</li><li>随着字典操作的不断进行，待rehash操作完成之后，会将trehashidx重新置为-1，表示rehash操作结束。</li></ol><h3 id="渐进式rehash注意事项"><a href="#渐进式rehash注意事项" class="headerlink" title="渐进式rehash注意事项"></a>渐进式rehash注意事项</h3><p>渐进式rehash过程中，</p><ul><li>增加、删除、修改都会在ht[0]和ht[1]两个表上进行。例如：对字典进行查找操作时，会现在ht[0]上作查找，如果查找失败，再去ht[1]上做查找</li><li>新增加的键都会添加到ht[1]上，从而保证ht[0]只减不增</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字典的实现&quot;&gt;&lt;a href=&quot;#字典的实现&quot; class=&quot;headerlink&quot; title=&quot;字典的实现&quot;&gt;&lt;/a&gt;字典的实现&lt;/h2&gt;&lt;p&gt;字典的底层是基于哈希表实现的,哈希表中的每一个节点保存了字典的一个键值对&lt;/p&gt;
&lt;h3 id=&quot;哈希表的实现&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据库的学习</title>
    <link href="https://shaojunying.github.io/2020/10/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/10/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-25T12:36:36.000Z</published>
    <updated>2021-04-04T05:42:02.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器的数据结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个redisDb数组，其中的每一项对应redis的一个数据库</span></span><br><span class="line">    redisDb * redisDb;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// redis数据库的数量 </span></span><br><span class="line">    <span class="keyword">int</span> redisDbNum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，redisServer中一个redisDb数组存储所有数据库对应的指针，redisDbNum存储数据库的数量</p><h2 id="客户端切换数据库"><a href="#客户端切换数据库" class="headerlink" title="客户端切换数据库"></a>客户端切换数据库</h2><p>Redis客户端的数据结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 客户端当前数据库的指针</span></span><br><span class="line">    redisDb * db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，redisClient中一个redisDb指针存储当前数据库的地址，切换数据库只需修改该指针的值即可。该指针的值都是redisServer中数据库数组的地址。</p><h2 id="redis数据库的结构"><a href="#redis数据库的结构" class="headerlink" title="redis数据库的结构"></a>redis数据库的结构</h2><p>redisDb结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 存储该数据库中的所有键值对</span></span><br><span class="line">    dict * dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 存储每个有过期时间的键对应的过期时间</span></span><br><span class="line">    dict * expires;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，字典类型的dict存储数据库中的所有键值对，key即为键，value为键值对的值，之后对键值对的增删改查都是对dict变量进行操作。</p><p>字典类型的expires存储数据库中含有过期时间的键及其过期时间，key为键，value为过期时间对应的时间戳。其中两个字典中相同的键对应的key是同一个key，避免了内存浪费。对于过期时间的增删改查也是基于expires变量进行的。</p><p>redis中设置过期时间有四种方式，分别是设置生存时间或过期时间，单位是秒或毫秒，最终都被转化为同一种方式：以毫秒为单位的过期时间。</p><p>TTL指令可以返回指定key对应的剩余存活时间，具体实现就是过期的时间戳减去当前时间戳。</p><h2 id="redis过期键的删除方式"><a href="#redis过期键的删除方式" class="headerlink" title="redis过期键的删除方式"></a>redis过期键的删除方式</h2><h3 id="三种可能的删除策略"><a href="#三种可能的删除策略" class="headerlink" title="三种可能的删除策略"></a>三种可能的删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>为键设置过期时间时启动一个定时器，在过期时间来临时，立即删除这个键</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>对内存最友好，但是占用太多CPU时间。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>在到达过期时间不会立即删除，而是在获取key对应的值的时候判断该key是否到期，如果到期则直接删除，之后返回空；否则返回对应的value值。</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>对CPU最友好，但是会造成内存浪费，甚至导致内存泄漏。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间检查一次数据库，删除其中过期的键。</p><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>前两种方案的折中方案，对于CPU和内存都较友好。但是较难把握每次检查之间的间隔时间，如果太长将退化为惰性删除；太短又会退化为定时删除。</p><h3 id="Redis采用的删除策略"><a href="#Redis采用的删除策略" class="headerlink" title="Redis采用的删除策略"></a>Redis采用的删除策略</h3><p>Redis采用惰性删除和定期删除两种方案。</p><h4 id="惰性删除-1"><a href="#惰性删除-1" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>Redis在对于<strong>任何</strong>键进行读写的时候，都会首先执行惰性删除，如果过期则删除并返回空，否则返回对应的值</p><h4 id="定期删除-1"><a href="#定期删除-1" class="headerlink" title="定期删除"></a>定期删除</h4><p>Redis会定期轮询整个数据库，从数据库中随机选择指定个键，如果键过期就删除。并且在定期删除超时后退出，下次从下一个数据库进行定期删除。</p><p>伪代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认每次检查的数据库数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认每次从每个数据库中随机取的键的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前要执行定期删除的数据库序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>()&#123;</span><br><span class="line">    <span class="comment">// 获取当前数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据库序号指向下一个数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中随机选择指定个元素,</span></span><br><span class="line">    <span class="comment">// 如果超过过期时间,就删除该元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前函数执行超时了,退出,下次从下一个数据库开始执行</span></span><br><span class="line">    <span class="comment">// 否则继续下一轮循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主从同步的删除方式"><a href="#主从同步的删除方式" class="headerlink" title="主从同步的删除方式"></a>主从同步的删除方式</h3><p>主从同步中从服务器发现过期键不进行删除,而是等待主服务器删除过期键之后发来删除指令才进行删除。从而保证了主从服务器的数据的一致性。</p><h3 id="RDB和AOF中的过期键删除"><a href="#RDB和AOF中的过期键删除" class="headerlink" title="RDB和AOF中的过期键删除"></a>RDB和AOF中的过期键删除</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB在保存的时候只会保存为过期的键，读取RDB文件时，主服务器会忽略过期键，但是从服务器仍会读取过期键。在之后主从服务器进行数据同步时从服务器的数据会被清空，所以过期键一般不会对RDB操作造成影响。</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>如果有键过期，系统会对AOF文件追加一条DEL指令</p><p>所以在客户端获取过期的键时会分为三步：</p><ol><li>删除键</li><li>向AOF追加DEL命令</li><li>返回空</li></ol><p>在AOF文件重写的过程中，会忽略过期的键</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;服务器中的数据库&quot;&gt;&lt;a href=&quot;#服务器中的数据库&quot; class=&quot;headerlink&quot; title=&quot;服务器中的数据库&quot;&gt;&lt;/a&gt;服务器中的数据库&lt;/h2&gt;&lt;p&gt;Redis服务器的数据结构如下所示&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring整合Elasticsearch</title>
    <link href="https://shaojunying.github.io/2020/10/19/Spring%E6%95%B4%E5%90%88Elasticsearch/"/>
    <id>https://shaojunying.github.io/2020/10/19/Spring%E6%95%B4%E5%90%88Elasticsearch/</id>
    <published>2020-10-19T07:29:30.000Z</published>
    <updated>2021-04-04T05:42:02.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看本篇文章之前请先看上一篇<a href="https://shaojunying.github.io/2020/10/18/Elasticsearch%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">Elasticsearch的安装与使用</a></p></blockquote><a id="more"></a><h2 id="Spring整合Elasticsearch"><a href="#Spring整合Elasticsearch" class="headerlink" title="Spring整合Elasticsearch"></a>Spring整合Elasticsearch</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>首先在<code>pom.xml</code>中使用如下命令引入Elasticsearch</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h3><p>在<code>application.properties</code>中指定如下配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># elasticsearch</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-name</span>=<span class="string">community</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure><h3 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(indexName = &quot;discusspost&quot;, type = &quot;_doc&quot;, shards = 6, replicas = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscussPost</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;uuuu-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZZ&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> commentCount;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>要搜索的中文属性要用<code>analyzer</code>和<code>searchAnalyzer</code>指定分词器</li><li><code>Date</code>要使用<code>@Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;uuuu-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ&quot;)</code>注解</li></ul><h3 id="配置repository"><a href="#配置repository" class="headerlink" title="配置repository"></a>配置repository</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscussPostRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">DiscussPost</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Integer是DiscussPost类id的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    discussPostRepository.save(discussPostMapper.selectDiscussPostById(<span class="number">114</span>));</span><br><span class="line">    discussPostRepository.save(discussPostMapper.selectDiscussPostById(<span class="number">234</span>));</span><br><span class="line">    discussPostRepository.save(discussPostMapper.selectDiscussPostById(<span class="number">235</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscussPost discussPost = discussPostMapper.selectDiscussPostById(<span class="number">114</span>);</span><br><span class="line">    Assert.assertNotNull(discussPost);</span><br><span class="line">    discussPost.setContent(<span class="string">&quot;哈哈啊&quot;</span>);</span><br><span class="line">    discussPostRepository.save(discussPost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    discussPostRepository.delete(discussPostMapper.selectDiscussPostById(<span class="number">114</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除全部数据"><a href="#删除全部数据" class="headerlink" title="删除全部数据"></a>删除全部数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteAll() &#123;</span><br><span class="line">    discussPostRepository.deleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-不带高亮"><a href="#查询-不带高亮" class="headerlink" title="查询(不带高亮)"></a>查询(不带高亮)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NativeSearchQuery build = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">            .withQuery(QueryBuilders.multiMatchQuery(<span class="string">&quot;互联网&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;content&quot;</span>))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;type&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;score&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;createTime&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withPageable(PageRequest.of(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">            .withHighlightFields(</span><br><span class="line">                    <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;title&quot;</span>).preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;content&quot;</span>).preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>)</span><br><span class="line">            ).build();</span><br><span class="line">    Page&lt;DiscussPost&gt; page = discussPostRepository.search(build);</span><br><span class="line">    System.out.println(page.getTotalElements());</span><br><span class="line">    System.out.println(page.getTotalPages());</span><br><span class="line">    System.out.println(page.getNumber());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    <span class="keyword">for</span> (DiscussPost discussPost : page) &#123;</span><br><span class="line">        System.out.println(discussPost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-带高亮"><a href="#查询-带高亮" class="headerlink" title="查询(带高亮)"></a>查询(带高亮)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchWithHighlight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NativeSearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">            .withQuery(QueryBuilders.multiMatchQuery(<span class="string">&quot;小哥哥&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;content&quot;</span>))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;type&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;score&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withSort(SortBuilders.fieldSort(<span class="string">&quot;createTime&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">            .withPageable(PageRequest.of(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">            .withHighlightFields(</span><br><span class="line">                    <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;title&quot;</span>), <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">            ).build();</span><br><span class="line">    SearchHits&lt;DiscussPost&gt; searchHits = elasticsearchOperations.search(searchQuery, DiscussPost.class);</span><br><span class="line">    List&lt;SearchHit&lt;DiscussPost&gt;&gt; searchHitList = searchHits.getSearchHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit&lt;DiscussPost&gt; discussPostSearchHit : searchHitList) &#123;</span><br><span class="line">        System.out.println(discussPostSearchHit.getHighlightFields());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>如果中途遇到一个中文词语被拆分成汉字了,比如”互联网”被拆分成”互”、”联”、”网”,就是当前索引没有设置中文索引,可以参考<a href="https://shaojunying.github.io/2020/10/18/Elasticsearch%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">Elasticsearch的安装与使用</a>中3.10中文查询,将索引删除,之后重新创建索引并指定分词器.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看本篇文章之前请先看上一篇&lt;a href=&quot;https://shaojunying.github.io/2020/10/18/Elasticsearch%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/&quot;&gt;Elasticsearch的安装与使用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Elasticsearch" scheme="https://shaojunying.github.io/tags/Elasticsearch/"/>
    
    <category term="Spring" scheme="https://shaojunying.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java并发的学习</title>
    <link href="https://shaojunying.github.io/2020/10/18/Java%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/10/18/Java%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-18T13:45:33.000Z</published>
    <updated>2021-04-04T05:42:02.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="一个实例中的synchronized方法每次只能由一个线程运行"><a href="#一个实例中的synchronized方法每次只能由一个线程运行" class="headerlink" title="一个实例中的synchronized方法每次只能由一个线程运行"></a>一个实例中的synchronized方法每次只能由一个线程运行</h3><p>例如Bank类中有两个方法(存钱和取钱)被synchronized修饰,那么如果其中一个在执行,另一个就不能被另一个线程执行,(具体来说就是一个人不能进行存钱和取钱操作,即使在不同的线程下)</p><p>以下两种方式等价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized-静态方法"><a href="#synchronized-静态方法" class="headerlink" title="synchronized 静态方法"></a>synchronized 静态方法</h3><p>synchronized静态方法使用的锁是xxx.class,而非静态方法锁的是类的实例(this).两者都是只能同时由一个线程执行.</p><a id="more"></a><h3 id="几个关键字"><a href="#几个关键字" class="headerlink" title="几个关键字"></a>几个关键字</h3><p>如果执行wait、notify、notifyAll方法的线程不持有锁，将会抛出异常IllegalMonitorStateException。</p><p>应该尽可能使用notifyAll，使用notify可能出发一些问题。</p><p>调用Sleep不会进入等待队列</p><p>Sleep的调用线程会睡眠，而不是调用实例</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;synchronized关键字&quot;&gt;&lt;a href=&quot;#synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字&quot;&gt;&lt;/a&gt;synchronized关键字&lt;/h2&gt;&lt;h3 id=&quot;一个实例中的synchronized方法每次只能由一个线程运行&quot;&gt;&lt;a href=&quot;#一个实例中的synchronized方法每次只能由一个线程运行&quot; class=&quot;headerlink&quot; title=&quot;一个实例中的synchronized方法每次只能由一个线程运行&quot;&gt;&lt;/a&gt;一个实例中的synchronized方法每次只能由一个线程运行&lt;/h3&gt;&lt;p&gt;例如Bank类中有两个方法(存钱和取钱)被synchronized修饰,那么如果其中一个在执行,另一个就不能被另一个线程执行,(具体来说就是一个人不能进行存钱和取钱操作,即使在不同的线程下)&lt;/p&gt;
&lt;p&gt;以下两种方式等价&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;synchronized-静态方法&quot;&gt;&lt;a href=&quot;#synchronized-静态方法&quot; class=&quot;headerlink&quot; title=&quot;synchronized 静态方法&quot;&gt;&lt;/a&gt;synchronized 静态方法&lt;/h3&gt;&lt;p&gt;synchronized静态方法使用的锁是xxx.class,而非静态方法锁的是类的实例(this).两者都是只能同时由一个线程执行.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch的安装与使用</title>
    <link href="https://shaojunying.github.io/2020/10/18/Elasticsearch%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://shaojunying.github.io/2020/10/18/Elasticsearch%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-10-18T07:38:29.000Z</published>
    <updated>2021-04-04T05:42:02.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>可以通过<a href="https://www.elastic.co/start">此链接</a>下载到最新版Elasticsearch.</p><a id="more"></a><p>下载之后将其解压在一个文件夹中即可,这里解压的目录是<code>C:\elasticsearch-x.x.x</code></p><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p>配置<code>elasticsearch-x.x.x\config</code>目录下的<code>elasticsearch.yml</code>文件</p><ul><li>修改<code>cluster.name</code>,这里设置为<code>cluster.name: community</code></li><li>修改<code>path.data</code>和<code>path.logs</code>,这里分别设置为<code>path.data: C:\Users\shao\elasticSearch\data</code>和<code>path.logs: C:\Users\shao\elasticSearch\logs</code></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>双击<code>elasticsearch-x.x.x\bin</code>下的<code>elasticsearch.bat</code>即可启动服务.</p><h3 id="获取健康信息"><a href="#获取健康信息" class="headerlink" title="获取健康信息"></a>获取健康信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/health?v&quot;</span></span><br></pre></td></tr></table></figure><h3 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes?v&quot;</span></span><br></pre></td></tr></table></figure><h3 id="获取索引信息"><a href="#获取索引信息" class="headerlink" title="获取索引信息"></a>获取索引信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/test&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">&quot;localhost:9200/test&quot;</span></span><br></pre></td></tr></table></figure><h3 id="向索引中添加数据"><a href="#向索引中添加数据" class="headerlink" title="向索引中添加数据"></a>向索引中添加数据</h3><p>PUT <code>http://localhost:9200/test/_doc/1</code><br>body设置为json格式,内容为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;title&quot;</span>:<span class="string">&quot;hello&quot;</span>,</span><br><span class="line"><span class="attr">&quot;content&quot;</span>: <span class="string">&quot;How are you&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(如果索引不存在将自动创建索引)</p><p>(向索引中更新数据也是这条命令)</p><h3 id="向索引中查询数据"><a href="#向索引中查询数据" class="headerlink" title="向索引中查询数据"></a>向索引中查询数据</h3><p>GET <code>localhost:9200/test/_doc/1</code></p><p>即可查询test索引中id为1的数据</p><h3 id="向索引中删除数据"><a href="#向索引中删除数据" class="headerlink" title="向索引中删除数据"></a>向索引中删除数据</h3><p>DELETE <code>localhost:9200/test/_doc/1</code></p><p>即可删除test索引中id为1的数据</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>先向索引test中添加如下两条数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;title&quot;</span>:<span class="string">&quot;互联网求职&quot;</span>,</span><br><span class="line"><span class="attr">&quot;content&quot;</span>: <span class="string">&quot;寻求一份运营的岗位&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;title&quot;</span>:<span class="string">&quot;互联网招聘&quot;</span>,</span><br><span class="line"><span class="attr">&quot;content&quot;</span>: <span class="string">&quot;招聘一名资深程序员&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不指定参数查询"><a href="#不指定参数查询" class="headerlink" title="不指定参数查询"></a>不指定参数查询</h4><p>GET <code>localhost:9200/test/_search?q=title:求职</code></p><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">31</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;互联网招聘&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;招聘一名资深程序员&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;互联网求职&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;寻求一份运营的岗位&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上,将返回所有数据</p><h4 id="简单参数查询"><a href="#简单参数查询" class="headerlink" title="简单参数查询"></a>简单参数查询</h4><p>GET <code>localhost:9200/test/_search?q=title:求职</code></p><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">0.5753642</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">0.5753642</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;互联网求职&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;寻求一份运营的岗位&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上,将返回title中包含求职的消息</p><h4 id="复杂参数查询"><a href="#复杂参数查询" class="headerlink" title="复杂参数查询"></a>复杂参数查询</h4><p>POST <code>localhost:9200/test/_search</code></p><p>body中json格式的数据如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:<span class="string">&quot;岗位&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>:[<span class="string">&quot;title&quot;</span>,<span class="string">&quot;content&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">0.5753642</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">0.5753642</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;互联网求职&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;寻求一份运营的岗位&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上,将返回标题或内容包含岗位的数据</p><h3 id="中文查询"><a href="#中文查询" class="headerlink" title="中文查询"></a>中文查询</h3><h4 id="为索引指定分词器"><a href="#为索引指定分词器" class="headerlink" title="为索引指定分词器"></a>为索引指定分词器</h4><p>POST <code>http://localhost:9200/discusspost/_mapping</code></p><p>data:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上命令为content字段指定中文分词器</p><h4 id="查询索引的分词器"><a href="#查询索引的分词器" class="headerlink" title="查询索引的分词器"></a>查询索引的分词器</h4><p>GET <code>http://localhost:9200/discusspost/_mapping</code></p><p>如果返回结果中content字段为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;content&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">        &quot;keyword&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">            &quot;ignore_above&quot;: 256</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则说明没有为该字段中文分词器,成功后的结果应该如下图所示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;content&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">    &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">    &quot;search_analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><em>注意:如果要修改当前分词器,可能会提示冲突,可以删除索引之后重新创建,之后再指定分词器</em></p><h4 id="中文搜索"><a href="#中文搜索" class="headerlink" title="中文搜索"></a>中文搜索</h4><p>POST <code>http://localhost:9200/discusspost/_search</code></p><p>data:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123; <span class="attr">&quot;match&quot;</span> : &#123; <span class="attr">&quot;content&quot;</span> : <span class="string">&quot;就业形势&quot;</span> &#125;&#125;,</span><br><span class="line">    <span class="attr">&quot;highlight&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span> : [<span class="string">&quot;&lt;tag1&gt;&quot;</span>, <span class="string">&quot;&lt;tag2&gt;&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span> : [<span class="string">&quot;&lt;/tag1&gt;&quot;</span>, <span class="string">&quot;&lt;/tag2&gt;&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;content&quot;</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>其中tags可以不指定,默认为<em></em></p><p>之后搜索结果包含highlight字段,如下所示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;content&quot;: [</span><br><span class="line">        <span class="string">&quot;大家的“哀嚎”与“悲惨遭遇”牵动了每日潜伏于讨论区的牛客&lt;tag1&gt;小哥哥&lt;/tag1&gt;小姐姐们的心，于是牛客决定：是时候为大家做点什么了！&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;下载与安装&quot;&gt;&lt;a href=&quot;#下载与安装&quot; class=&quot;headerlink&quot; title=&quot;下载与安装&quot;&gt;&lt;/a&gt;下载与安装&lt;/h2&gt;&lt;p&gt;可以通过&lt;a href=&quot;https://www.elastic.co/start&quot;&gt;此链接&lt;/a&gt;下载到最新版Elasticsearch.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Elasticsearch" scheme="https://shaojunying.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 19. 删除链表的倒数第N个节点</title>
    <link href="https://shaojunying.github.io/2020/10/18/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://shaojunying.github.io/2020/10/18/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2020-10-18T02:15:53.000Z</published>
    <updated>2021-04-04T05:42:02.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">题目链接</a></p></blockquote><h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><a id="more"></a><p>n应该从1开始,因为链表的最后一个节点是倒数第一个节点</p><p>从链表的头开始,先向后前进n步</p><ul><li>①如果中途遇到空指针说明n&gt;链表长度,n是非法的</li><li>②如果在结尾遇到空指针,说明要删除的节点是链表的头节点</li><li>没有遇到空指针==&gt;当前指针(快指针)前进一格,之后另一个指针(慢指针)从头开始,两个指针同时前进,直到遇到空指针.此时慢指针指向的是要删除节点的前驱节点,③删除慢指针的下一个节点即可.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> n &gt; <span class="number">0</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">// 快指针先前进n步</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">                <span class="comment">// 要删除的是第一个节点</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125; <span class="comment">// n大于链表的长度,参数不合法</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除链表非头节点</span></span><br><span class="line">            ListNode slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除slow.next</span></span><br><span class="line">            ListNode next = slow.next;</span><br><span class="line">            slow.next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h3><h4 id="为什么慢指针指向的是要删除节点的前驱节点"><a href="#为什么慢指针指向的是要删除节点的前驱节点" class="headerlink" title="为什么慢指针指向的是要删除节点的前驱节点"></a>为什么慢指针指向的是要删除节点的前驱节点</h4><p>因为快指针前进了n+1次之后慢指针才和快指针同时前进,所以慢指针距离快指针n+1步,快指针指向null时慢指针指向倒数第n+1个节点,而倒数第n个节点的前驱节点就是倒数第n+1个节点.</p><h4 id="快指针会不会在前进过程中发生空指针异常"><a href="#快指针会不会在前进过程中发生空指针异常" class="headerlink" title="快指针会不会在前进过程中发生空指针异常"></a>快指针会不会在前进过程中发生空指针异常</h4><p>不会,在循环中都会进行判断,此时肯定不会,而在前n次循环结束之后,如果快指针为null,那么说明要删除的是第一个节点,也就不会向下执行.一旦向下执行就说明快指针不为空,也就不会发生空指针异常</p><h2 id="双指针2"><a href="#双指针2" class="headerlink" title="双指针2"></a>双指针2</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>该方法与前面方法相比在链表头部加一个哑节点,通过这种方式在寻找节点的前驱节点时不需要单独考虑头节点,因为头节点也有前驱节点(哑节点),从而将上面方法的②合并到③中.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> n &gt; <span class="number">0</span>;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="comment">// 快指针先前进n步</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != n &amp;&amp; first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// n大于链表长度</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的哑节点最终指向要删除节点的前驱节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要删除的是second.next</span></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题解释-1"><a href="#问题解释-1" class="headerlink" title="问题解释"></a>问题解释</h3><h4 id="为什么哑节点最终指向要删除节点的前驱节点"><a href="#为什么哑节点最终指向要删除节点的前驱节点" class="headerlink" title="为什么哑节点最终指向要删除节点的前驱节点"></a>为什么哑节点最终指向要删除节点的前驱节点</h4><p>快指针从头节点开始前进n步,此时快指针与头节点相距n步,也就与哑节点相距n+1步,所以最终快指针指向null时慢指针指向倒数第n+1个节点…</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;双指针解法&quot;&gt;&lt;a href=&quot;#双指针解法&quot; class=&quot;headerlink&quot; title=&quot;双指针解法&quot;&gt;&lt;/a&gt;双指针解法&lt;/h2&gt;&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
    <category term="链表" scheme="https://shaojunying.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://shaojunying.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <link href="https://shaojunying.github.io/2020/10/15/LeetCode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>https://shaojunying.github.io/2020/10/15/LeetCode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</id>
    <published>2020-10-15T13:03:32.000Z</published>
    <updated>2021-04-04T05:42:02.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个数组记录每一层被遍历的节点中最左侧的那个,之后将每层未遍历的最右侧节点指向它即可</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root, list, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, List&lt;Node&gt; list, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// depth:深度,从0开始</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; depth + <span class="number">1</span>) &#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            list.add(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = list.get(depth);</span><br><span class="line">            list.set(depth, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树</span></span><br><span class="line">        dfs(node.right, list, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 左子树</span></span><br><span class="line">        dfs(node.left, list, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在层序遍历的过程中,将每一层的节点使用next指针依次相连</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node cur = queue.remove();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>)&#123;</span><br><span class="line">                    cur.next = queue.element();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用已建立的next指针"><a href="#使用已建立的next指针" class="headerlink" title="使用已建立的next指针"></a>使用已建立的next指针</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>假设此时位于第i层,那么第i层节点之间的next指针已建立完毕,下面建立i+1层的next:</p><ul><li>要建立的两个节点父节点(父节点位于第i层)相同,那么直接相连即可</li><li>父节点不同,则两个节点父节点一定通过next相连,且父节点在左边的是右节点,父节点在右边的是左节点.那么将左父节点的右孩子的next指针指向右父节点的左孩子.</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node curHead = root;</span><br><span class="line">        <span class="keyword">while</span> (curHead.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新curHead下一层的next指针</span></span><br><span class="line">            Node curNode = curHead;</span><br><span class="line">            <span class="keyword">while</span> (curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 同一父节点</span></span><br><span class="line">                curNode.left.next = curNode.right;</span><br><span class="line">                <span class="comment">// 跨父节点</span></span><br><span class="line">                <span class="keyword">if</span> (curNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    curNode.right.next = curNode.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curHead = curHead.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;递归遍历&quot;&gt;&lt;a href=&quot;#递归遍历&quot; class=&quot;headerlink&quot; title=&quot;递归遍历&quot;&gt;&lt;/a&gt;递归遍历&lt;/h2&gt;&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;使用一个数组记录每一层被遍历的节点中最左侧的那个,之后将每层未遍历的最右侧节点指向它即可&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
    <category term="二叉树" scheme="https://shaojunying.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="https://shaojunying.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="链表" scheme="https://shaojunying.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>kafka的安装与使用</title>
    <link href="https://shaojunying.github.io/2020/10/15/kafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://shaojunying.github.io/2020/10/15/kafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-10-15T01:17:15.000Z</published>
    <updated>2021-04-04T05:42:02.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从<a href="https://kafka.apache.org/downloads">此链接</a>中下载最新的binary版本即可</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将tgz压缩包解压,最好放在根目录,比如<code>C:\kafka_2.13-2.6.0</code>这样.否则可能会报错命令行过长</p><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><ul><li>将文件<code>C:\kafka_2.13-2.6.0\config\server.properties</code>中的<code>log.dirs</code>修改为<code>log.dirs=C:/Users/shao/kafka_logs/</code></li><li>将文件<code>C:\kafka_2.13-2.6.0\config\zookeeper.properties</code>中的<code>dataDir</code>修改为<code>dataDir=C:/Users/shao/zookeeper</code></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="运行zookeeper"><a href="#运行zookeeper" class="headerlink" title="运行zookeeper"></a>运行zookeeper</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\kafka_2.13-2.6.0</span><br><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure><h3 id="运行kafka"><a href="#运行kafka" class="headerlink" title="运行kafka"></a>运行kafka</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\kafka_2.13-2.6.0</span><br><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure><h2 id="创建一个topic"><a href="#创建一个topic" class="headerlink" title="创建一个topic"></a>创建一个topic</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\kafka_2.13-2.6.0\bin\windows</span><br><span class="line">kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partition 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><ul><li><code>bootstrap-server</code>指定新topic对应的主机</li><li><code>replication-factor</code>指定备份个数</li><li><code>partition</code>指定分区个数,也即将topic分成几块</li></ul><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\kafka_2.13-2.6.0\bin\windows</span><br><span class="line">kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\kafka_2.13-2.6.0\bin\windows</span><br><span class="line">kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><h2 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h2><h3 id="maven引入"><a href="#maven引入" class="headerlink" title="maven引入"></a>maven引入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置kafka"><a href="#配置kafka" class="headerlink" title="配置kafka"></a>配置kafka</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kafka</span></span><br><span class="line"><span class="comment"># 主机端口</span></span><br><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="comment"># 组id,在consumer.properties,默认为test-consumer-group</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">community-consumer-group</span></span><br><span class="line"><span class="comment"># 是否允许自动提交</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.enable-auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 自动提交的时间间隔,这里设置为3s</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-commit-interval</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        producer.send(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;shao&quot;</span>);</span><br><span class="line">        producer.send(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;jun&quot;</span>);</span><br><span class="line">        producer.send(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;ying&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String topic, String content)</span></span>&#123;</span><br><span class="line">        kafkaTemplate.send(topic, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span></span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener(topics = &#123;&quot;test&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(ConsumerRecord&lt;String, Object&gt; consumerRecord)</span></span>&#123;</span><br><span class="line">        System.out.println(consumerRecord.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://kafka.apache.org/downloads&quot;&gt;此链接&lt;/a&gt;中下载最新的binary版本即可&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="https://shaojunying.github.io/tags/Spring/"/>
    
    <category term="消息队列" scheme="https://shaojunying.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="kafka" scheme="https://shaojunying.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 142 环形链表2</title>
    <link href="https://shaojunying.github.io/2020/10/10/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/"/>
    <id>https://shaojunying.github.io/2020/10/10/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/</id>
    <published>2020-10-10T02:53:15.000Z</published>
    <updated>2021-04-04T05:42:02.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(node))&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h2><h3 id="快慢指针法为什么一定会相遇"><a href="#快慢指针法为什么一定会相遇" class="headerlink" title="快慢指针法为什么一定会相遇"></a>快慢指针法为什么一定会相遇</h3><ul><li>快慢指针法中快指针每次向前移动两格,慢指针每次移动一格,如果链表中存在环,那么最终快慢指针一定会都进入环中.</li><li>假如慢指针到环起始点时快指针还需要n步才能到达环的起始点(n小于环的总长度len),那么n步之后快慢指针即可相遇,因为快慢指针的相对速度为1,每次移动之后快指针距离将会缩小一格,也因此快慢指针一定会相遇,且此时慢指针在环中移动的距离不超过环长度len.</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="示意图"></p><ul><li>如图所示,a表示链表中非环部分的长度,b表示相遇前慢指针走过的长度,c表示环中剩余的长度</li><li>那么直到相遇慢指针走过的长度为(a+b),快指针走过的长度为a+(n+1)b+nc</li><li>因为快指针速度为慢指针的2倍,所以a+(n+1)b+nc = 2(a+b),化简可得a=c+(n-1)(b+c)</li><li>那么如果指针1从链表头部出发,慢指针从相遇点继续前进,最终两者将会在环的入点处相遇,因为指针1到达环的起始点时,慢指针一定经过若干圈的环内循环再次到达环起始点.</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 快慢指针分别向前移动</span></span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                <span class="comment">// 指向相同节点,说明找到了环</span></span><br><span class="line">                <span class="comment">// 慢指针继续向前走,新创建一个指针指向起始点,两者的相遇点就是环的入点</span></span><br><span class="line">                ListNode node = head;</span><br><span class="line">                <span class="keyword">while</span> (node != slow)&#123;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast == null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哈希表法&quot;&gt;&lt;a href=&quot;#哈希表法&quot; class=&quot;headerlink&quot; title=&quot;哈希表法&quot;&gt;&lt;/a&gt;哈希表法&lt;/h2&gt;&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
    <category term="双指针" scheme="https://shaojunying.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="https://shaojunying.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>gitee的模拟登录</title>
    <link href="https://shaojunying.github.io/2020/10/07/gitee%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <id>https://shaojunying.github.io/2020/10/07/gitee%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</id>
    <published>2020-10-07T08:29:16.000Z</published>
    <updated>2021-04-04T05:42:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>看了<a href="https://github.com/yanglbme/gitee-pages-action">自动部署Gitee Pages脚本</a>,分析并模拟Gitee Pages登录</p><a id="more"></a><h2 id="分析POST请求"><a href="#分析POST请求" class="headerlink" title="分析POST请求"></a>分析POST请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encrypt_key: password</span><br><span class="line">utf8: ✓</span><br><span class="line">authenticity_token: jyna10uRx6nksFsKrOXOGlTaH1en+FjlrfBunGv6j5M&#x3D;</span><br><span class="line">redirect_to_url: </span><br><span class="line">user[login]: shaojunying</span><br><span class="line">encrypt_data[user[password]]: Yb5KLQgGxbEM8M3kVn00yVuNJwjQ4vWjYjPbJj1O9wh5au1cXd1eVb+WJkOfWfio4q&#x2F;2t7mOVCpH70cv5NtrNPw5ZW4lkj&#x2F;JJOt3L9w6P4RU3tQpB4fqofP&#x2F;j5BhU1C4FJLpylSENdMj2Lf5S5PUTA18QF1ykrpaqgKqrejZtRE&#x3D;</span><br><span class="line">user[remember_me]: 0</span><br></pre></td></tr></table></figure><p>上面是login的post请求中的form-data,分析可知<code>user[login]</code>表示的是用户名,而<code>encrypt_data[user[password]]</code>是加密之后的密码,需要在之前的页面中找encrypt_data.</p><p>在network中全局搜索encrypt_data,发现请求<code>https://assets.gitee.com/assets/encrypt-b4407d80fc0fd4eb67c8709f21684588.js</code>包含encrypt_data关键字,下面是定位到的代码段,在注释中对代码进行分析.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.gon &amp;&amp; <span class="built_in">window</span>.gon.encrypt &amp;&amp; <span class="built_in">window</span>.gon.encrypt.enabled) &#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">window</span>.JSEncrypt</span><br><span class="line">          , e = <span class="built_in">window</span>.gon.encrypt.separator</span><br><span class="line">          , i = <span class="built_in">window</span>.gon.encrypt.password_key</span><br><span class="line">          , r = $(<span class="string">&quot;meta[name=csrf-token]&quot;</span>)[<span class="number">0</span>].content</span><br><span class="line">          , n = <span class="string">&#x27;&lt;input type=&quot;hidden&quot; name=&quot;encrypt_key&quot;&gt;&#x27;</span></span><br><span class="line">          , s = <span class="string">&#x27;&lt;input type=&quot;hidden&quot; name=&quot;encrypt_data[$name]&quot;&gt;&#x27;</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个设置了属性 data-encrypt=&quot;true&quot;的form,对其中的password加密</span></span><br><span class="line">        $(<span class="string">&quot;form[data-encrypt=true]&quot;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> o = $(<span class="built_in">this</span>)</span><br><span class="line">              , h = $(n)</span><br><span class="line">              , a = o.data(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">            <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;password&quot;</span>:</span><br><span class="line">                <span class="comment">// i是public_key,通过查询可知定义在get https://gitee.com/login请求中</span></span><br><span class="line">                t.setPublicKey(i),</span><br><span class="line">                <span class="comment">// h是一个新的隐式input,之后内容是&lt;input type=&quot;hidden&quot; name=&quot;encrypt_key&quot; value=&quot;password&quot;&gt;</span></span><br><span class="line">                h.val(a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            o.prepend(h),</span><br><span class="line">            $(<span class="string">&quot;[data-encrypt=true]&quot;</span>, o).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 加密表单中需要加密的项</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 表单项对应的元素,一般为input</span></span><br><span class="line">                <span class="keyword">var</span> i = $(<span class="built_in">this</span>)</span><br><span class="line">                    <span class="comment">// 表单项的名字</span></span><br><span class="line">                  , n = i.attr(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                  <span class="comment">// 为加密后的元素创建一个表单项(之后提交时将作为请求参数)</span></span><br><span class="line">                  <span class="comment">// &lt;input type=&quot;hidden&quot; name=&quot;encrypt_data[user[password]]&quot; value=&quot;*****&quot;&gt;</span></span><br><span class="line">                  , o = $(s.replace(<span class="string">&quot;$name&quot;</span>, n));</span><br><span class="line">                i.before(o),</span><br><span class="line">                <span class="comment">// 监听要加密的表单项,一旦发生变化就修改加密之后的元素值</span></span><br><span class="line">                i.change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// r是X-CSRF-Token,get登录页面时可以得到该值</span></span><br><span class="line">                    <span class="comment">// e是分隔符,也是在get登录页面时获取</span></span><br><span class="line">                    <span class="comment">// i是用户输入的原始密码</span></span><br><span class="line">                    <span class="comment">// 之后将三者拼接并为加密之后的结果创建新input</span></span><br><span class="line">                    <span class="keyword">var</span> n = t.encrypt(r + e + i.val());</span><br><span class="line">                    o.val(n),</span><br><span class="line">                    i.removeAttr(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="分析登录的get请求"><a href="#分析登录的get请求" class="headerlink" title="分析登录的get请求"></a>分析登录的get请求</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;authenticity_token&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-param&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 就是post需要的X-CSRF-Token --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;dBWUUHIYc94LTKTOEnAZkxvyntZgqFN5cNli2S9DLUQ=&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://assets.gitee.com/assets/application-f5fd3f1c2641f843a7ce17e94fa11583.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// separator,password_key都在这里面可以找到</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//&lt;![CDATA[</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.gon = &#123;&#125;;gon.locale=<span class="string">&quot;zh-CN&quot;</span>;gon.sentry_dsn=<span class="literal">null</span>;gon.baidu_register_hm_push=<span class="literal">null</span>;gon.info=&#123;<span class="string">&quot;controller_path&quot;</span>:<span class="string">&quot;sessions&quot;</span>,<span class="string">&quot;action_name&quot;</span>:<span class="string">&quot;new&quot;</span>,<span class="string">&quot;current_user&quot;</span>:<span class="literal">false</span>&#125;;gon.tour_env=&#123;<span class="string">&quot;current_user&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;action_name&quot;</span>:<span class="string">&quot;new&quot;</span>,<span class="string">&quot;original_url&quot;</span>:<span class="string">&quot;http://gitee.com/login&quot;</span>,<span class="string">&quot;controller_path&quot;</span>:<span class="string">&quot;sessions&quot;</span>&#125;;gon.yunpian_key=<span class="literal">false</span>;gon.encrypt=&#123;<span class="string">&quot;enabled&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;separator&quot;</span>:<span class="string">&quot;$gitee$&quot;</span>,<span class="string">&quot;password_key&quot;</span>:<span class="string">&quot;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDIrn+WB2Yi4ABAL5Tq6E09tumY\nqVTFdpU01kCDUmClczJOCGZriLNMrshmN9NJxazpqizPthwS1OIK3HwRLEP9D3GL\n7gCnvN6lpIpoVwppWd65f/rK2ewv6dstN0fCmtVj4WsLUchWlgNuVTfWljiBK/Dc\nYkfslRZzCq5Fl3ooowIDAQAB\n-----END PUBLIC KEY-----\n&quot;</span>&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Python模拟页面的登录请求"><a href="#Python模拟页面的登录请求" class="headerlink" title="Python模拟页面的登录请求"></a>Python模拟页面的登录请求</h2><p>网页中使用的是JSEncrypt库,而python中使用的库是rsa.</p><ul><li>通过<a href="https://www.jianshu.com/p/7a4645691c68">博客</a>可知可以使用<code>public_key = rsa.PublicKey.load_pkcs1_openssl_pem(PUBLIC_KEY.encode())</code>函数设置公钥.</li><li>通过<a href="https://blog.csdn.net/Enderman_xiaohei/article/details/89325747">博客</a>可知,可以使用  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">&quot;rtU/xUiVseZhYLnpC6UncwKVba6aUQEC9II7OnLgLpQ=&quot;</span> + <span class="string">&quot;$gitee$&quot;</span> + <span class="string">&quot;password&quot;</span></span><br><span class="line">data = rsa.encrypt(data.encode(), public_key)</span><br><span class="line">data = base64.b64encode(data).decode()</span><br></pre></td></tr></table></figure>  的方法获取加密之后的字符串.其余的直接使用requests库发送相应的请求即可</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后的代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">PUBLIC_KEY = <span class="string">&quot;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDIrn+WB2Yi4ABAL5Tq6E09tumY&quot;</span> \</span><br><span class="line">             <span class="string">&quot;\nqVTFdpU01kCDUmClczJOCGZriLNMrshmN9NJxazpqizPthwS1OIK3HwRLEP9D3GL\n7gCnvN6lpIpoVwppWd65f&quot;</span> \</span><br><span class="line">             <span class="string">&quot;/rK2ewv6dstN0fCmtVj4WsLUchWlgNuVTfWljiBK/Dc\nYkfslRZzCq5Fl3ooowIDAQAB\n-----END PUBLIC KEY-----\n &quot;</span></span><br><span class="line">public_key = rsa.PublicKey.load_pkcs1_openssl_pem(PUBLIC_KEY.encode())</span><br><span class="line">data = <span class="string">&quot;rtU/xUiVseZhYLnpC6UncwKVba6aUQEC9II7OnLgLpQ=&quot;</span> + <span class="string">&quot;$gitee$&quot;</span> + <span class="string">&quot;ddfbhjvdbghd&quot;</span></span><br><span class="line">data = rsa.encrypt(data.encode(), public_key)</span><br><span class="line">data = base64.b64encode(data).decode()</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>有些变量在这里被写死了,实际需要通过get请求获取,稍加修改即可.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看了&lt;a href=&quot;https://github.com/yanglbme/gitee-pages-action&quot;&gt;自动部署Gitee Pages脚本&lt;/a&gt;,分析并模拟Gitee Pages登录&lt;/p&gt;</summary>
    
    
    
    
    <category term="爬虫" scheme="https://shaojunying.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>redis的AOF持久化存储</title>
    <link href="https://shaojunying.github.io/2020/10/06/redis%E7%9A%84AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <id>https://shaojunying.github.io/2020/10/06/redis%E7%9A%84AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</id>
    <published>2020-10-06T12:53:49.000Z</published>
    <updated>2021-04-04T05:42:02.665Z</updated>
    
    <content type="html"><![CDATA[<p>AOF全称为Append Only File,即仅仅向文件中追加命令</p><h2 id="AOF实现"><a href="#AOF实现" class="headerlink" title="AOF实现"></a>AOF实现</h2><a id="more"></a><ul><li><p>AOF保存了每一条写指令(包括删除指令)</p></li><li><p>AOF的实现包含三步,分别是追加,写入和同步.</p><ul><li>追加. 将最新的写命令追加到缓冲区中.</li><li>写入和同步.将缓冲区中的内容写入到文件中,以及将内存中的文件同步到磁盘中.(如果不同步到磁盘中,发生故障时内容一样会丢失)</li></ul></li><li><p>可以通过修改redis.conf文件中的appendfsync的值来修改AOF的写入和同步方式:</p><ul><li>no.只是将缓存区中数据写入文件缓冲区中,何时同步文件缓冲区和磁盘中的文件由操作系统决定.(速度最快,但是安全性较差,发生故障会丢失较多数据)</li><li>always.将缓冲区中数据写入文件缓冲区中,每一轮事件循环都同步文件缓冲区和磁盘中的文件.(安全性最高,但是性能较差,需要进行大量磁盘读写操作)(该种方法也可能会丢失数据,最多丢失一个事件循环的写命令).</li><li>everysec.将缓冲区中数据写入文件缓冲区中,在每一轮事件循环中判断,如果距离上次同步超过一秒,就再次同步文件缓冲区和磁盘中的文件.(折中办法)</li></ul></li><li><p>事件循环:Redis的服务进程就是一个事件循环,该事件循环包括三部分:</p><ul><li>用户命令的处理.读取用户命令并打印相应输出,还可能会将命令写入aof缓冲区</li><li>处理时间事件.</li><li>判断是否需要写入和同步aof文件.</li></ul></li></ul><h2 id="AOF的载入和还原"><a href="#AOF的载入和还原" class="headerlink" title="AOF的载入和还原"></a>AOF的载入和还原</h2><ul><li>启动redis时,若开启了AOF功能则载入aof文件,否则载入rdb文件.</li><li>载入aof文件时,redis将逐个执行aof文件中的命令(离线)</li></ul><h2 id="AOF的重写"><a href="#AOF的重写" class="headerlink" title="AOF的重写"></a>AOF的重写</h2><p>不断追加AOF文件将导致AOF文件体积膨胀,为了解决这个问题,需要进行AOF文件重写.</p><ul><li>AOF文件重写会开启一个新的进程,并复制当前数据库的状态</li><li>之后逐个读取每个数据库中的数据,根据数据库中的数据创建写指令存入新AOF文件(不涉及旧AOF文件的读写).</li><li>AOF重写的过程中主进程继续接受用户的指令,如果用户输入了写指令,则该指令除了被执行以外,还会追加到AOF缓冲区和AOF重写缓冲区.</li><li>如果AOF重写完毕之后,将会向主进程发送信号,之后主进程阻塞用户命令的处理,将AOF重写缓冲区中的指令追加到新AOF文件中,追加完毕之后,新AOF文件将会原子地替换掉旧AOF文件.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;AOF全称为Append Only File,即仅仅向文件中追加命令&lt;/p&gt;
&lt;h2 id=&quot;AOF实现&quot;&gt;&lt;a href=&quot;#AOF实现&quot; class=&quot;headerlink&quot; title=&quot;AOF实现&quot;&gt;&lt;/a&gt;AOF实现&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Windows下如何开启Redis的AOF持久化</title>
    <link href="https://shaojunying.github.io/2020/10/06/Windows%E4%B8%8B%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFRedis%E7%9A%84AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://shaojunying.github.io/2020/10/06/Windows%E4%B8%8B%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFRedis%E7%9A%84AOF%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-10-06T11:31:37.000Z</published>
    <updated>2021-04-04T05:42:02.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式1-命令行中开启"><a href="#方式1-命令行中开启" class="headerlink" title="方式1(命令行中开启)"></a>方式1(命令行中开启)</h2><ol><li>通过命令 redis-server命令启动redis或者redis-server —service-start启动redis服务</li><li>通过redis-cli进入redis命令行</li><li>执行config set appendonly yes 即可启动redis的AOF持久化</li></ol><a id="more"></a><p><em>注意: 此修改只在该命令行中生效,重新启动redis之后将失效.</em></p><h2 id="方式2-修改redis-windows-conf开启"><a href="#方式2-修改redis-windows-conf开启" class="headerlink" title="方式2(修改redis.windows.conf开启)"></a>方式2(修改redis.windows.conf开启)</h2><ol><li>打开redis.windows.conf修改appendonly no为appendonly yes</li><li>执行 redis-server redis.windows.conf 启动redis</li><li>执行redis-cli即可.</li></ol><p><em>注意:此种方式需要窗口在执行完第2.步之后不能关闭命令行窗口,关闭之后将不能访问redis服务.</em></p><h2 id="方式3-修改redis-windows-service-conf开启-推荐"><a href="#方式3-修改redis-windows-service-conf开启-推荐" class="headerlink" title="方式3(修改redis.windows-service.conf开启)(推荐)"></a>方式3(修改redis.windows-service.conf开启)(推荐)</h2><ol><li>打开redis.windows-service.conf修改appendonly no为appendonly yes</li><li>执行redis-server –service-install redis.windows.conf命令重新安装redis服务</li><li>通过redis-server —service-start启动redis服务</li><li>执行redis-cli即可</li></ol><p><em>注意:此种方式是修改redis服务的启动方式,启动之后可以关闭窗口,服务不会因为窗口的关闭而关闭.</em></p><h2 id="开启过程中遇到的其他问题"><a href="#开启过程中遇到的其他问题" class="headerlink" title="开启过程中遇到的其他问题"></a>开启过程中遇到的其他问题</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><ul><li>[7948] 06 Oct 19:08:11.903 # Can’t open the append-only file: Input/output error</li></ul><p><img src="1.png" alt="问题1截图"></p><p>使用管理员模式重新启动命令行即可</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;方式1-命令行中开启&quot;&gt;&lt;a href=&quot;#方式1-命令行中开启&quot; class=&quot;headerlink&quot; title=&quot;方式1(命令行中开启)&quot;&gt;&lt;/a&gt;方式1(命令行中开启)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过命令 redis-server命令启动redis或者redis-server —service-start启动redis服务&lt;/li&gt;
&lt;li&gt;通过redis-cli进入redis命令行&lt;/li&gt;
&lt;li&gt;执行config set appendonly yes 即可启动redis的AOF持久化&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://shaojunying.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Windows" scheme="https://shaojunying.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 77组合题解</title>
    <link href="https://shaojunying.github.io/2020/09/08/LeetCode-77%E7%BB%84%E5%90%88%E9%A2%98%E8%A7%A3/"/>
    <id>https://shaojunying.github.io/2020/09/08/LeetCode-77%E7%BB%84%E5%90%88%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-08T13:28:19.000Z</published>
    <updated>2021-04-04T05:42:02.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n+<span class="number">1</span>, k,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> k, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// TODO 遍历和是否选择每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 选择j</span></span><br><span class="line">            list.add(j);</span><br><span class="line">            dfs(j + <span class="number">1</span>, n, k, list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>类似上边,只不过上面是每次遍历每个元素作为开头,这里考虑每个元素<code>选择</code>和<code>不选择</code>的两种情况.依据的原理是<code>C(n,k) = C(n-1,k)+C(n-1,k-1)</code>,其中等号左边从n个元素中选择k个元素,等号右边表示不选当前元素和选当前元素的情况.</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n+<span class="number">1</span>, k,<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> k, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 选择元素i</span></span><br><span class="line">        list.add(i);</span><br><span class="line">        dfs(i+<span class="number">1</span>, n, k,list);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不选择元素i</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, n, k, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;回溯1&quot;&gt;&lt;a href=&quot;#回溯1&quot; class=&quot;headerlink&quot; title=&quot;回溯1&quot;&gt;&lt;/a&gt;回溯1&lt;/h1&gt;&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 347.前 K 个高频元素 题解</title>
    <link href="https://shaojunying.github.io/2020/09/07/Leetcode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E9%A2%98%E8%A7%A3/"/>
    <id>https://shaojunying.github.io/2020/09/07/Leetcode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-07T13:19:41.000Z</published>
    <updated>2021-04-04T05:42:02.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>首先记录每个数字的频次 ==&gt; O(n)</li><li>构建一个包含k个元素的最大堆 ==&gt; O(nlog(k))</li><li>将堆中的所有元素转为一个数组 ==&gt; O(k)</li></ol><a id="more"></a><p>复杂度:O(nlogk)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt;= k;</span><br><span class="line">        <span class="comment">// 堆排序</span></span><br><span class="line">        <span class="comment">// 1. 统计每个数字对应的频次</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.computeIfAbsent(num, i-&gt;<span class="number">0</span>);</span><br><span class="line">            map.put(num, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建一个最多包含k个元素的最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k,(o1, o2) -&gt; map.get(o2)-map.get(o1));</span><br><span class="line">        heap.addAll(map.keySet());</span><br><span class="line">        <span class="comment">// 3. 将最大堆转化为数组</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = heap.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自己实现-heap"><a href="#自己实现-heap" class="headerlink" title="自己实现 heap"></a>自己实现 heap</h3><p>TODO</p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><ol><li>统计每个数字的频次</li><li>依照快排找到频次最大的k个数字</li></ol><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>TODO</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><ol><li>统计每个数字的频次 ==&gt; O(n)</li><li>统计每个频次对应的数字 ==&gt; O(n)</li><li>依次选择最大频次的K个数字 ==&gt; O(n+k)</li></ol><p>第3.步通过从nums.length开始遍历,从而找到频次最大的K个数字</p><p>复杂度: O(n)</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt;= k;</span><br><span class="line">        <span class="comment">// 1.统计每个数字对应的频次</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.computeIfAbsent(num, i -&gt; <span class="number">0</span>);</span><br><span class="line">            map.put(num, count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.记录每个频次对应的数字</span></span><br><span class="line">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; frequency2Nums = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            List&lt;Integer&gt; list = frequency2Nums.computeIfAbsent(value, i-&gt;<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            list.add(key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 3.取出频次最大的k个数字</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; ans.length; j --)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = frequency2Nums.get(j);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; list.size() &amp;&amp; i &lt; ans.length; m++, i++) &#123;</span><br><span class="line">                    ans[i] = list.get(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先记录每个数字的频次 ==&amp;gt; O(n)&lt;/li&gt;
&lt;li&gt;构建一个包含k个元素的最大堆 ==&amp;gt; O(nlog(k))&lt;/li&gt;
&lt;li&gt;将堆中的所有元素转为一个数组 ==&amp;gt; O(k)&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 257.二叉树的所有路径</title>
    <link href="https://shaojunying.github.io/2020/09/04/LeetCode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>https://shaojunying.github.io/2020/09/04/LeetCode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</id>
    <published>2020-09-04T05:57:19.000Z</published>
    <updated>2021-04-04T05:42:02.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>深度优先遍历所有的节点,遇到叶节点就将字符串加入</p><a id="more"></a><p>易错点:</p><p><code>if (root == null)</code>是递归的终止条件,不能用于判断是否是叶节点,叶节点的判断应该是<code>if (root.left == null &amp;&amp; root.right == null)</code>,也即一个节点左右节点都为空.</p><h2 id="代码1-使用全局变量递归"><a href="#代码1-使用全局变量递归" class="headerlink" title="代码1(使用全局变量递归)"></a>代码1(使用全局变量递归)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 节点中整数位数不确定,因此应该统计加入整数之前字符串长度.</span></span><br><span class="line">        <span class="keyword">int</span> len = builder.length();</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(root.val);</span><br><span class="line">            ans.add(builder.toString());</span><br><span class="line">            builder.delete(len, builder.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(root.val).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">            builder.delete(len,builder.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root, paths, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;String&gt; paths, String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            paths.add(path+root.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(root.left, paths, path + root.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            dfs(root.right, paths, path + root.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; pathQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        pathQueue.add(root.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = nodeQueue.remove();</span><br><span class="line">            String path = pathQueue.remove();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                paths.add(path.substring(<span class="number">0</span>,path.length()-<span class="number">2</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nodeQueue.add(node.left);</span><br><span class="line">                    pathQueue.add(path + node.left.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodeQueue.add(node.right);</span><br><span class="line">                    pathQueue.add(path + node.right.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;深度优先遍历&quot;&gt;&lt;a href=&quot;#深度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;深度优先遍历&quot;&gt;&lt;/a&gt;深度优先遍历&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;深度优先遍历所有的节点,遇到叶节点就将字符串加入&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 220.存在重复元素 III</title>
    <link href="https://shaojunying.github.io/2020/09/03/LeetCode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III/"/>
    <id>https://shaojunying.github.io/2020/09/03/LeetCode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III/</id>
    <published>2020-09-03T14:36:29.000Z</published>
    <updated>2021-04-04T05:42:02.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力解法-复杂度-O-n2-运行时间-661ms"><a href="#暴力解法-复杂度-O-n2-运行时间-661ms" class="headerlink" title="暴力解法(复杂度:O(n2) 运行时间:661ms)"></a>暴力解法(复杂度:O(n2) 运行时间:661ms)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历数组中所有元素,将每个元素与其后的k个元素作比较,判断是否满足条件</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; Math.min(nums.length, i + k + <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="comment">// 判断nums[i]和nums[j]的差值是否小于t</span></span><br><span class="line">                <span class="keyword">if</span> ( Math.abs((<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)nums[j])&lt;= t)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树-复杂度-O-n-log-min-k-n-运行时间-23-ms"><a href="#平衡二叉树-复杂度-O-n-log-min-k-n-运行时间-23-ms" class="headerlink" title="平衡二叉树(复杂度:O(n*log(min(k,n)) 运行时间:23 ms)"></a>平衡二叉树(复杂度:O(n*log(min(k,n)) 运行时间:23 ms)</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>暴力解法每一次都要遍历窗口中的所有元素来判断条件二是否满足,可以使用一个二叉树存储当前元素前的k个元素,之后判断区间内元素是否满足条件只需判断小于当前元素的最大元素和大于该元素的最小元素.在二叉树中元素个数大于k时从二叉树中删除最早插入的元素.</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            Integer successor = set.ceiling(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (successor != <span class="keyword">null</span> &amp;&amp; Math.abs(successor - nums[i]) &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer predecessor = set.floor(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (predecessor != <span class="keyword">null</span> &amp;&amp; Math.abs(predecessor - nums[i]) &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (set.size() &gt; k)&#123;</span><br><span class="line">                set.remove(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="桶排序-复杂度-O-n-运行时间-17ms"><a href="#桶排序-复杂度-O-n-运行时间-17ms" class="headerlink" title="桶排序(复杂度: O(n) 运行时间: 17ms)"></a>桶排序(复杂度: O(n) 运行时间: 17ms)</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>将所有元素放入若干个桶中,桶中分别保存[0,t],[t+1,2t+1]….,由于每个桶中包含的元素范围为[n*(t+1), (n+1)*(t+1)-1],所以要判断指定元素是否满足条件只需判断当前元素对应的桶和左右相邻的两个桶.并且也需要保证所有桶中的元素个数大于k的时候删除最早加入的元素.</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Java中 -1/2 为 0 这里应该为 -1 所以修改</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (a + <span class="number">1</span>) / b - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将所有元素放入若干个桶中,桶中分别保存[0,t],[t+1,2t+1]....</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> m = (<span class="keyword">long</span>) t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> index = getID(nums[i], m);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(index))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(index - <span class="number">1</span>) &amp;&amp; Math.abs(map.get(index - <span class="number">1</span>) - nums[i]) &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(index + <span class="number">1</span>) &amp;&amp; Math.abs(map.get(index + <span class="number">1</span>) - nums[i]) &lt;= t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(index, (<span class="keyword">long</span>) nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; k)&#123;</span><br><span class="line">                map.remove(getID(nums[i-k], m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;暴力解法-复杂度-O-n2-运行时间-661ms&quot;&gt;&lt;a href=&quot;#暴力解法-复杂度-O-n2-运行时间-661ms&quot; class=&quot;headerlink&quot; title=&quot;暴力解法(复杂度:O(n2) 运行时间:661ms)&quot;&gt;&lt;/a&gt;暴力解法(复杂度:O(n2) 运行时间:661ms)&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;遍历数组中所有元素,将每个元素与其后的k个元素作比较,判断是否满足条件&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 486.预测赢家题解</title>
    <link href="https://shaojunying.github.io/2020/09/01/LeetCode-486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6%E9%A2%98%E8%A7%A3/"/>
    <id>https://shaojunying.github.io/2020/09/01/LeetCode-486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-01T12:57:28.000Z</published>
    <updated>2021-04-04T05:42:02.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力解法1-递归"><a href="#暴力解法1-递归" class="headerlink" title="暴力解法1(递归)"></a>暴力解法1(递归)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用一个总分数score表示玩家1和玩家2分数的差值,<br>在区间[start,end]内</p><ul><li>玩家1尽可能使score的值大,从而使[0,len-1]之间的score最大,从而尽可能使玩家1分数&gt;玩家2分数</li><li>玩家1尽可能使score的值小,从而使[0,len-1]之间的score最小,从而尽可能使玩家1分数&lt;玩家2分数</li></ul><p>之后每次选择都是,轮到玩家1时,将从左右边界中选择尽可能使score大的情况,轮到玩家2时与此相反.</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// [start, end]</span></span><br><span class="line">       <span class="comment">// 返回值: [start,end]玩家1分数能超过玩家2的最大值</span></span><br><span class="line">       <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// turn &gt; 0 ==&gt; 玩家1 ==&gt; 比较正的结果</span></span><br><span class="line">       <span class="comment">// turn &lt; 0 ==&gt; 玩家2 ==&gt; 比较负数的结果</span></span><br><span class="line">       <span class="keyword">int</span> left = dfs(nums, start + <span class="number">1</span>, end, turn * -<span class="number">1</span>) + turn * nums[start];</span><br><span class="line">       <span class="keyword">int</span> right = dfs(nums, start, end - <span class="number">1</span>, turn * -<span class="number">1</span>) + turn * nums[end];</span><br><span class="line">       <span class="comment">// 最终比较玩家1的分数是否&gt;=玩家2 ==&gt; 玩家1的分数减去玩家2也即score是否&gt;=0 </span></span><br><span class="line">       <span class="comment">// ==&gt; 对于一个固定区间[start,end],左右两个边界中玩家1选择使score尽可能大,从而保证[0,len-1]之间的结果尽可能大</span></span><br><span class="line">       <span class="comment">// ==&gt; 同理,玩家2将选择使score尽可能小,促使玩家2-玩家1结果较大,从而保证[0,len-1]之间的结果尽可能小</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(turn * left, turn * right) * turn;</span><br><span class="line">   &#125;<span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="暴力解法2"><a href="#暴力解法2" class="headerlink" title="暴力解法2"></a>暴力解法2</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>基本同上, 本轮传参每次选择之后玩家1和2的分数,之后再选择最有利于自己的选择,最后返回本选择是否能使玩家1最终成功.</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, len - <span class="number">1</span>, <span class="keyword">true</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> end, <span class="keyword">boolean</span> is1, <span class="keyword">int</span> score1, <span class="keyword">int</span> score2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [start, end]</span></span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> score1 &gt;= score2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is1)&#123;</span><br><span class="line">            <span class="comment">// 更新1的分数</span></span><br><span class="line">            <span class="comment">// left || right 只要左右选择中有一个可以使玩家1成功,玩家1就一定能成功/</span></span><br><span class="line">            <span class="keyword">boolean</span> left = dfs(nums, start + <span class="number">1</span>, end, <span class="keyword">false</span>, score1 + nums[start], score2);</span><br><span class="line">            <span class="keyword">if</span> (left) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> dfs(nums, start, end - <span class="number">1</span>, <span class="keyword">false</span>, score1 + nums[end], score2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 必须两个选择都使玩家1成功,也即玩家2失败,玩家2无论怎么选都一定失败,从而使玩家1成功.</span></span><br><span class="line">            <span class="keyword">boolean</span> left = dfs(nums, start + <span class="number">1</span>, end, <span class="keyword">true</span>, score1, score2 + nums[start]);</span><br><span class="line">            <span class="keyword">boolean</span> right = dfs(nums, start, end - <span class="number">1</span>, <span class="keyword">true</span>, score1, score2 + nums[end]);</span><br><span class="line">            <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里m(i,j)表示区间[i,j]内A选择可以取得的A的分数减去B的最大差值,那么[i,j]区间A选择取得的A,B最大差值就等于</p><ol><li>[i+1, j]区间内B选择取得的BA最大插值,也等于A选择的AB最大差值.只是为了此时使B选.因此应该使nums[i]-(B选择BA的最大差值) ==&gt;nums[i] - memo[i+1,j];</li><li>[i,j-1]区间,同上.<br>中的最大值</li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记忆化搜索</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            memo[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memo[i][j] = max(nums[i]-memo[i+1][j],nums[j]-memo[i][j-1]);</span></span><br><span class="line">        <span class="comment">// (i,j)表示 从i到j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">                    memo[i][j] = Math.max(nums[i] - memo[i+<span class="number">1</span>][j], nums[j]-memo[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>][len-<span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;暴力解法1-递归&quot;&gt;&lt;a href=&quot;#暴力解法1-递归&quot; class=&quot;headerlink&quot; title=&quot;暴力解法1(递归)&quot;&gt;&lt;/a&gt;暴力解法1(递归)&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;使用一个总分数score表示玩家1和玩家2分数的差值,&lt;br&gt;在区间[start,end]内&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家1尽可能使score的值大,从而使[0,len-1]之间的score最大,从而尽可能使玩家1分数&amp;gt;玩家2分数&lt;/li&gt;
&lt;li&gt;玩家1尽可能使score的值小,从而使[0,len-1]之间的score最小,从而尽可能使玩家1分数&amp;lt;玩家2分数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后每次选择都是,轮到玩家1时,将从左右边界中选择尽可能使score大的情况,轮到玩家2时与此相反.&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://shaojunying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>TODO</title>
    <link href="https://shaojunying.github.io/2020/08/22/TODO/"/>
    <id>https://shaojunying.github.io/2020/08/22/TODO/</id>
    <published>2020-08-22T08:18:23.000Z</published>
    <updated>2021-04-04T05:42:02.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h2><a id="more"></a><ul><li>集合</li><li>两种代理</li><li>Bean生命周期</li><li>自动配置注解</li><li>redis</li><li>JVM</li><li>锁</li><li>内存空间</li><li>秒杀</li><li>分布式</li><li>Mybatis</li><li>慕课 Java并发核心知识讲解</li><li>理论+实战 构建完整JVM知识体系</li><li>掌握Java项目面试武功心法，面试弯道超车</li><li>算法与数据结构体系课</li><li>Java架构师成长直通车</li><li>线程八大核心+Java并发底层原理精讲</li><li>Zookeeper源码分析</li><li>一站式学习Java网络编程 全面理解BIO/NIO/AIO</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java面试&quot;&gt;&lt;a href=&quot;#Java面试&quot; class=&quot;headerlink&quot; title=&quot;Java面试&quot;&gt;&lt;/a&gt;Java面试&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring MVC的学习</title>
    <link href="https://shaojunying.github.io/2020/08/19/Spring-MVC%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/08/19/Spring-MVC%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-08-19T07:09:55.000Z</published>
    <updated>2021-04-04T05:42:02.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ul><li>表现层</li><li>业务层</li><li>数据层</li></ul><a id="more"></a><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>Model: 模型层</li><li>View: 视图层</li><li>Controller: 控制层</li></ul><p>MVC三层集体解决表现层的问题。</p><p><img src="MVC.png"></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>前端控制器: <code>DispatcherServlet</code></p><p>过程:<br><img src="MVC%E5%8E%9F%E7%90%86.png"></p><p>如图，前端控制器会收到浏览器发来的请求，之后匹配相应的Controller，Controller会处理该请求并返回model给前端控制器，前端控制器会再将model传给View Template，View Template会生成一个HTML并返回给前端控制器，之后前端控制器将网页作为response返回给浏览器。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;三层架构&quot;&gt;&lt;a href=&quot;#三层架构&quot; class=&quot;headerlink&quot; title=&quot;三层架构&quot;&gt;&lt;/a&gt;三层架构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表现层&lt;/li&gt;
&lt;li&gt;业务层&lt;/li&gt;
&lt;li&gt;数据层&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://shaojunying.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring的学习</title>
    <link href="https://shaojunying.github.io/2020/08/16/Spring%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/08/16/Spring%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-08-16T03:58:58.000Z</published>
    <updated>2021-04-04T05:42:02.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Spring 是一个轻量级的控制反转、面向切面编程的框架(容器)</p><a id="more"></a><p>Spring 发展到现在,唯一的一个弊端是配置十分繁琐。为了解决这个问题引入了Spring Boot，Spring Boot遵循“约定大于配置”的原则。开发人员只需要规定应用中不符合约定的部分，提高了开发效率。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="几个易混淆的概念"><a href="#几个易混淆的概念" class="headerlink" title="几个易混淆的概念"></a>几个易混淆的概念</h3><ul><li><code>控制反转(IOC)</code> 是一种设计原则</li><li><code>依赖导致原则(DIP)</code>也是一种设计原则</li><li><code>依赖注入(DI)</code>是一种遵循了IOC和DIP的一种设计模式</li><li><code>IOC container</code>是一个框架，该框架实现了依赖注入这一设计模式。</li></ul><h3 id="使用-IOC-container-管理自己创建的bean"><a href="#使用-IOC-container-管理自己创建的bean" class="headerlink" title="使用 IOC container 管理自己创建的bean"></a>使用 IOC container 管理自己创建的bean</h3><p>AlphaDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlphaDao</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，声明了一个AlphaDao接口。</p><p>AlphaDaoMyBatisImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlphaDaoMyBatisImpl</span> <span class="keyword">implements</span> <span class="title">AlphaDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyBatis&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，创建了一个AlphaDao接口的实现，并在该类上添加了@Repositort注解，之后Spring将会自动装配该bean。</p><p>CommunityApplicationTests.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunityApplicationTests</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AlphaDao alphaDao = applicationContext.getBean(AlphaDaoMyBatisImpl.class,AlphaDao.class);</span><br><span class="line">        System.out.println(alphaDao.select());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>MyBatis</p></blockquote><p>如上所示，通过调用<code>applicationContext.getBean(AlphaDaoMyBatisImpl.class,AlphaDao.class)</code>将会得到对应的bean。</p><h3 id="使用IOC-container管理第三方的bean"><a href="#使用IOC-container管理第三方的bean" class="headerlink" title="使用IOC container管理第三方的bean"></a>使用IOC container管理第三方的bean</h3><p>AlphaConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlphaConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDateFormat <span class="title">simpleDateFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上通过@Configuration声明了一个配置类，之后就可以在类内声明Bean。</p><p>CommunityApplicationTests.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunityApplicationTests</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = applicationContext.getBean(SimpleDateFormat.class);</span><br><span class="line">        System.out.println(simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>20-08-16 12:39:46</p></blockquote><p>如上，也可以使用applicationContext获取SimpleDateFormat Bean。</p><h3 id="使用IOC-container自动装配bean"><a href="#使用IOC-container自动装配bean" class="headerlink" title="使用IOC container自动装配bean"></a>使用IOC container自动装配bean</h3><p>可以通过对变量、set函数、构造器添加<code>@AutoWired</code>注解使Spring自动装配bean。</p><p><em>通过如上的实验可知，<code>Controller</code>、<code>Service</code>、<code>Repository</code>等注解是为了标识Spring应该装配的bean，所以应该添加在实现类上，而不是接口上。</em></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;Spring 是一个轻量级的控制反转、面向切面编程的框架(容器)&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://shaojunying.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven的学习</title>
    <link href="https://shaojunying.github.io/2020/08/14/Maven%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shaojunying.github.io/2020/08/14/Maven%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-08-14T13:53:14.000Z</published>
    <updated>2021-04-04T05:42:02.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>maven</code>是一个常用的包管理工具。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>创建项目</p><p>  命令<br>  <code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</code></p><ul><li><code>archetype:generate</code> 表示按照一个模板创建一个项目，其中<code>-DarchetypeArtifactId=maven-archetype-quickstart</code>指定了参照的模板，该模板是maven项目的常用模板。</li><li><code>-DartifactID</code>指定了该项目的根目录的名字，该项目的根目录名字即为<code>my-app</code>。</li><li><code>-DgroupID=com.mycompany.app</code>会在<code>my-app/src/main/java</code>目录下创建一个对应的<code>com/mycompany/app</code>文件夹，项目的代码将会保存在这个文件夹下。</li><li><code>-DinteractiveMode=false</code> 表示不会进入交互模式。</li></ul></li><li><p><code>mvn compile</code> 编译<code>my-app/src/main/java</code>目录下的<code>java</code>文件，在<code>my-app/target</code>文件夹下生成对应的<code>class</code>文件。这里不编译<code>test</code>文件。</p></li><li><p><code>mvn clean</code> 删除<code>my-app/target</code>目录。</p></li><li><p><code>mvn test</code> 编译<code>my-app/src/test/java</code>目录下的<code>java</code>文件，并运行进行测试。</p></li><li><p><code>mvn clean compile</code> 可以多个命令连续使用</p></li><li><p><code>mvn package</code> 将项目进行打包，在<code>my-app/target</code>目录下生成一个<code>my-app-1.0-SNAPSHOT.jar</code>文件。之后可以执行<code>java -cp target\my-app-1.0-SNAPSHOT.jar com.mycompany.app.App</code>运行App.java文件中的main函数。</p><ul><li><code>java -cp</code>中的cp表示classpath，其后两个参数分别时jar包的路径和项目主类的路径。</li></ul></li></ul><p><em>在输入类似<code>mvn compile</code>之类的指令时，mvn会顺序执行在maven执行序列中该指令之前的所有指令。</em></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;code&gt;maven&lt;/code&gt;是一个常用的包管理工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求的幂等性</title>
    <link href="https://shaojunying.github.io/2020/08/14/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://shaojunying.github.io/2020/08/14/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2020-08-14T08:42:19.000Z</published>
    <updated>2021-04-04T05:42:02.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><code>安全性</code> 该请求不改变服务端的数据。</li><li><code>幂等性</code> 进行多次相同的请求，服务端每次的最终结果是相同的。</li></ul><a id="more"></a><h2 id="各个请求"><a href="#各个请求" class="headerlink" title="各个请求"></a>各个请求</h2><table><thead><tr><th>请求</th><th>安全性</th><th>幂等性</th></tr></thead><tbody><tr><td>GET</td><td>是</td><td>是</td></tr><tr><td>POST</td><td>否</td><td>否</td></tr><tr><td>DELETE</td><td>否</td><td>是</td></tr><tr><td>PUT</td><td>否</td><td>是</td></tr><tr><td><em>DELETE被定义为也是幂等性的，进行多次 DELETE 操作服务端的结果相同，都是指定元素已经被删除了。尽管第一次和后面的调用返回的结果是不同的，第一次会返回删除成功，后面则会返回找不到指定元素(404)。</em></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;安全性&lt;/code&gt; 该请求不改变服务端的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;幂等性&lt;/code&gt; 进行多次相同的请求，服务端每次的最终结果是相同的。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HashMap和HashTable的区别</title>
    <link href="https://shaojunying.github.io/2020/07/17/HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://shaojunying.github.io/2020/07/17/HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-07-16T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li>HashTable为所有方法添加了synchronize关键字,保证了每个方法的线程安全性,但是降低了效率</li><li>HashMap不保证线程安全性,但是效率相对较高</li></ul><a id="more"></a><h2 id="继承的类不同"><a href="#继承的类不同" class="headerlink" title="继承的类不同"></a>继承的类不同</h2><ul><li>HashTable继承的是Dictionary类</li><li>HashMap继承的是AbstractMap类</li></ul><h2 id="对null的支持"><a href="#对null的支持" class="headerlink" title="对null的支持"></a>对null的支持</h2><ul><li>HashTable的key和value均不支持null,调用put时如果value为null将抛出NullPointerException,计算hash值会直接调用key的hashcode方法,如果key为空也将抛出异常</li><li>HashMap的key和value均支持null.HashMap对value值没有任何要求,在计算hashcode时会判断hashcode是否为null,如果为null,则直接用0作为hash值</li></ul><h2 id="初始化和扩容方式不同"><a href="#初始化和扩容方式不同" class="headerlink" title="初始化和扩容方式不同"></a>初始化和扩容方式不同</h2><ul><li>HashTable在调用构造函数时直接初始化了数组.默认初始容量为11.扩容时HashTable会将新容量设置为原来容量的2倍+1</li><li>HashMap在调用构造函数时只记录初始容量,在第一次put才会初始化数组.默认初始化容量为16.容量参数如果不是2的幂,会被转化为2的幂.扩容时新容量为原来容量的2倍</li></ul><h2 id="hash值的计算方法不同"><a href="#hash值的计算方法不同" class="headerlink" title="hash值的计算方法不同"></a>hash值的计算方法不同</h2><ul><li>HashTable会将hashcode去掉符号位(后31位)对数组长度取余作为数组的下标</li><li>如果key位null,则下标直接为0.HashMap会对hashcode的高16位和低16位做异或运算(<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>).之后将(<code>(n-1)&amp;hash</code>)作为数组的下标.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HashTable为所有方法添加了synchronize关键字,保证了每个方法的线程安全性,但是降低了效率&lt;/li&gt;
&lt;li&gt;HashMap不保证线程安全性,但是效率相对较高&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://shaojunying.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://shaojunying.github.io/2020/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://shaojunying.github.io/2020/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>解决两台物理机的通信问题,保证一台物理机向另一台物理机发送比特流,后者可以收到这些比特流</p><a id="more"></a><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>解决比特流传输中错传和数据的不完整等问题,将要传输的数据进行格式化</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输数据的过程中如何找目标节点以及到达目标节点的最佳路径</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层向上层用户传输高效的、可靠的、成本有效的数据传输服务</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>使网络通信更加方便</p><h2 id="TCP的3次握手"><a href="#TCP的3次握手" class="headerlink" title="TCP的3次握手"></a>TCP的3次握手</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手示意图"></p><ul><li>起初客户端处于关闭状态，服务端处于监听状态</li><li>第一次握手：客户端向服务端发送SYN包(seq=x)，并进入SYN_SEND状态等待服务端确认</li><li>第二次握手：服务端收SYN包，需要发送ACK包，同时，自己需要发送一个SYN包(seq=y)，即SYN+ACK包，之后服务端进入SYN_RSCV状态</li><li>第三次握手：客户端收到ACK+SYN包，需要向服务端发送ACK包，之后进入Established状态，服务端在收到ACK包之后也进入Established状态。三次握手完成。</li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>初始化Sequence Number的值</li><li>避免超时的连接请求到达服务器，使服务器尝试建立错误的连接。</li></ul><h2 id="TCP的4次挥手"><a href="#TCP的4次挥手" class="headerlink" title="TCP的4次挥手"></a>TCP的4次挥手</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手示意图"></p><ul><li>起初客户端和服务端都处于Established阶段</li><li>第一次挥手: 客户端向服务端发送FIN包(seq=u),关闭客户端向服务端的数据传送,进入fin-wait-1状态</li><li>第二次挥手: 服务端向客户端回复ACK包(ack=u+1),进入Close-wait状态,同时继续正常发送数据包</li><li>第三次挥手: 服务端将所有数据发送完毕之后,再次发送ACK包(ack=u+1),同时发送FIN包(seq=x)告诉客户端数据已发送完毕,之后进入Last-ack状态</li><li>第四次挥手: 客户端向服务端回复ACK包(ack=x+1),之后进入time-wait状态,等待2个MSL之后进入Close状态.服务端在收到ACK包之后直接进入Close状态</li></ul><h3 id="客户端最后等待2MSL的原因"><a href="#客户端最后等待2MSL的原因" class="headerlink" title="客户端最后等待2MSL的原因"></a>客户端最后等待2MSL的原因</h3><p><code>确保有足够的时间让服务端收到ACK包</code></p><p>第四次握手消息发出,一个MSL之后如果服务端仍没有收到ACK包,将会重发一个FIN包,该包需要MSL才能到达客户端,因此客户端需要2MSL的时间之后才能close.</p><h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><ul><li>TCP是全双工的,各方都需要发送和接受FIN和ACK</li><li>需要保证服务端的数据发送完毕.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;五层协议&quot;&gt;&lt;a href=&quot;#五层协议&quot; class=&quot;headerlink&quot; title=&quot;五层协议&quot;&gt;&lt;/a&gt;五层协议&lt;/h2&gt;&lt;h3 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h3&gt;&lt;p&gt;解决两台物理机的通信问题,保证一台物理机向另一台物理机发送比特流,后者可以收到这些比特流&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="https://shaojunying.github.io/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>https://shaojunying.github.io/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</id>
    <published>2020-06-25T13:00:58.000Z</published>
    <updated>2021-04-04T05:42:02.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p><code>ACID</code></p><a id="more"></a><ul><li>A(atomicity) <code>原子性</code> 事务中的操作要么都执行,要么都不执行.</li><li>C(consistency) <code>一致性</code> 事务只能将数据库从一个正确的状态转化为另一个正确的状态.例如银行的数据库中不论如何转账,应该保证所有人总钱数使固定的.</li><li>I(isolation) <code>隔离性</code> 隔离性是指数据库允许多个并发事务同时对数据进行读写和修改的能力. 隔离性可以分为四种级别<ul><li>read-uncommited(未提交读)</li><li>read-commited(提交读)</li><li>repeatable-read（可重复读）</li><li>serializable（串行化）</li></ul></li><li>D(durability) <code>持久性</code> </li></ul><h2 id="数据库并发访问产生的问题和数据库的隔离级别"><a href="#数据库并发访问产生的问题和数据库的隔离级别" class="headerlink" title="数据库并发访问产生的问题和数据库的隔离级别"></a>数据库并发访问产生的问题和数据库的隔离级别</h2><h3 id="数据库并发访问产生的问题"><a href="#数据库并发访问产生的问题" class="headerlink" title="数据库并发访问产生的问题"></a>数据库并发访问产生的问题</h3><ol><li>更新丢失</li><li>脏读</li><li>不可重复读</li><li>幻读</li></ol><h4 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h4><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">开始事务</td></tr><tr><td align="center">read a = 100</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">read a = 100</td></tr><tr><td align="center"></td><td align="center">a = a - 10 (a = 90)</td></tr><tr><td align="center"></td><td align="center">提交</td></tr><tr><td align="center">a = a - 10 (a = 90)</td><td align="center"></td></tr><tr><td align="center">提交</td><td align="center"></td></tr><tr><td align="center">造成更新丢失(此处应该为80)</td><td align="center"></td></tr></tbody></table><p>多个事务同时对一个数据进行更新,最终造成一部分事务的更新丢失.</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">开始事务</td></tr><tr><td align="center">read a = 100</td><td align="center"></td></tr><tr><td align="center">a = a - 10 (a = 90)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">read a = 90</td></tr><tr><td align="center">回滚</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读到脏数据</td></tr></tbody></table><p>一个事务读到了另一个事务修改之后的数据,但是之后后者进行了回滚,因此读到了脏数据.</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">开始事务</td></tr><tr><td align="center">read a = 100</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">read a = 100</td></tr><tr><td align="center"></td><td align="center">a = a - 10 (a = 90)</td></tr><tr><td align="center">read a = 90</td><td align="center"></td></tr><tr><td align="center">造成不可重复读</td><td align="center"></td></tr></tbody></table><p>在一个事务两次查询数据的过程中另一个事务更新了数据,造成了为进行任何写操作的事务两次读取到了不一样的数据.</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">开始事务</td></tr><tr><td align="center">查询得知数据库中有3条数据</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">向数据库中添加一条数据</td></tr><tr><td align="center">将所有行的指定列加1</td><td align="center"></td></tr><tr><td align="center">最终修改的行数为4造成了幻读</td><td align="center"></td></tr></tbody></table><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">开始事务</td></tr><tr><td align="center">查询得知没有id为1的数据</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">添加一条id为1的数据</td></tr><tr><td align="center">尝试添加id为1的数据(插入失败)</td><td align="center"></td></tr><tr><td align="center">最初查询结果为0条,第2次查询的结果为1条,造成幻读</td><td align="center"></td></tr></tbody></table><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个事务读取两次,得到的记录条数不一致</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><table><thead><tr><th align="center">隔离级别</th><th align="center">更新丢失</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">不允许出现</td><td align="center">允许出现</td><td align="center">允许出现</td><td align="center">允许出现</td></tr><tr><td align="center">提交读</td><td align="center">不允许出现</td><td align="center">不允许出现</td><td align="center">允许出现</td><td align="center">允许出现</td></tr><tr><td align="center">可重复读</td><td align="center">不允许出现</td><td align="center">不允许出现</td><td align="center">不允许出现</td><td align="center">允许出现</td></tr><tr><td align="center">串行化</td><td align="center">不允许出现</td><td align="center">不允许出现</td><td align="center">不允许出现</td><td align="center">不允许出现</td></tr></tbody></table><h4 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h4><p>在该隔离级别下会出现脏读,大部分情况下不允许脏读,但是这种模式数据库的并发是最好的</p><h4 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h4><p>这种模式是Oracle和SQL server的默认隔离级别</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>可重复读是MySQL的默认隔离级别.这种隔离级别但是可能会造成幻读,MySQL的InnoDB引擎可以通过next-key locks机制来避免幻读.</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p><code>串行调度</code>:不允许事务并发执行,事务一个接一个串行执行.</p><p><code>可串行化调度</code>:如果存在调度S,对于数据库的任何状态,该调度的执行结果等于一个串行调度的执行结果,则称该调度为<code>可串行化调度</code>.</p><p>该级别下可以解决幻读的问题,但是对并发的支持相对较差.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据库事务的四大特性&quot;&gt;&lt;a href=&quot;#数据库事务的四大特性&quot; class=&quot;headerlink&quot; title=&quot;数据库事务的四大特性&quot;&gt;&lt;/a&gt;数据库事务的四大特性&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ACID&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="https://shaojunying.github.io/2020/06/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>https://shaojunying.github.io/2020/06/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</id>
    <published>2020-06-22T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h2><p>快速查询数据。</p><a id="more"></a><h2 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h2><p>能把数据记录限定在一定查找范围的字段(主键、唯一键以及普通键等)。</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>一般使用B+树做存储索引。</p><p>B+树一些主要的特点：</p><ul><li>字数指针和关键字个数相同（读写代价更低）</li><li>非叶节点的字数指针P[i]，指向关键字值[K[i], K[i+1]）的子树</li><li>非叶节点仅用来做索引，数据都保存在叶子节点 （查询效果更稳定）</li><li>每个叶子节点都有一个指针指向下一个叶子节点(便于选择指定区间的元素，有利于对数据库进行扫描)</li></ul><p>优点：</p><ul><li>B+树的读写代价更低</li><li>B+树的查询效率更稳定</li><li>B+树更有利于对数据库进行扫描</li></ul><p>Hash表优点和缺点：</p><ul><li>优点<ul><li>B+树需要执行多次IO操作才能找到目标的数据记录，而Hash表只需进行一次IO操作</li></ul></li><li>缺点<ul><li>仅能满足=、“IN”操作，不能进行范围查询（&lt;、&gt;、between and）。</li><li>不能用来避免数据的排序操作</li><li>不能进行部分索引键的查询</li><li>不能避免表的扫描</li><li>遇到大量数据的hash值相同时，可能效率会低于B+树</li></ul></li></ul><h2 id="密集索引和稀疏索引"><a href="#密集索引和稀疏索引" class="headerlink" title="密集索引和稀疏索引"></a>密集索引和稀疏索引</h2><h3 id="密集索引"><a href="#密集索引" class="headerlink" title="密集索引"></a>密集索引</h3><p>每个数据记录的键值分别对应一个索引项</p><h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><ul><li>只有一部分数据记录的键值有索引项对应。</li><li>为了定位一条数据记录，需要首先找到小于等于目标记录的最大索引，之后从这一项开始进行顺序遍历，直到找到目标记录为止。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>稠密索引的查询速度更快，稀疏索引占用的空间更小，且更容易插入和删除等。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要使用索引&quot;&gt;&lt;a href=&quot;#为什么要使用索引&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用索引&quot;&gt;&lt;/a&gt;为什么要使用索引&lt;/h2&gt;&lt;p&gt;快速查询数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据库" scheme="https://shaojunying.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程的区别</title>
    <link href="https://shaojunying.github.io/2020/06/19/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://shaojunying.github.io/2020/06/19/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><a id="more"></a><ul><li><code>拥有资源</code> 进程是资源分配的基本单位，线程不拥有资源,可以访问隶属于进程的资源。</li><li><code>独立调度</code> 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换.</li><li><code>系统开销</code> 进程的创建和销毁过程中，系统都要为之分配或收回内存空间、I\O设备等，同时还要保存进程运行环境。而线程的切换只需要保存寄存器的状态。</li><li><code>通信方面</code> 线程之间可以通过读写同一进程中的变量进行通信，而进程之间通信需要通过IPC进行。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h2&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="https://shaojunying.github.io/2020/06/10/%E7%BA%BF%E7%A8%8B/"/>
    <id>https://shaojunying.github.io/2020/06/10/%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程 = 资源 + 指令执行序列</p><a id="more"></a><p><img src="%E7%BA%BF%E7%A8%8B.png"></p><p>如上图所示,线程在切换的时候只改变PC的值和寄存器影响,不会改变进程代码、进程数据、进程资源等。即映射表也不会切换。</p><p><code>线程</code>：保留了并发的优点，避免了进程切换的代价。</p><h2 id="多线程共享地址空间"><a href="#多线程共享地址空间" class="headerlink" title="多线程共享地址空间"></a>多线程共享地址空间</h2><p>浏览器启动多个线程。</p><p><img src="%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8.png"></p><p>其中获取文本的线程和显示文本的线程将会共享存储文本的内存区域。</p><h2 id="每个线程应该分别创建一个栈"><a href="#每个线程应该分别创建一个栈" class="headerlink" title="每个线程应该分别创建一个栈"></a>每个线程应该分别创建一个栈</h2><p>多线程中每个线程应该分别创建一个栈。栈内存储了各级调用要执行的下一条指令所在的地址。</p><p>在进行进程切换的过程中要先进行栈的切换。</p><p>创建线程需要分别创建TCB、栈，将程序的起始地址压入栈中。</p><h2 id="用户级线程与内核级线程"><a href="#用户级线程与内核级线程" class="headerlink" title="用户级线程与内核级线程"></a>用户级线程与内核级线程</h2><p><img src="%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png"></p><p>用户级线程虽然创建了多个线程，但是所有线程只对应一个进程调度。如果一个线程一直占用该进程的资源，那么该进程中的其他的线程也不能得到执行。</p><p>而内核级线程中每个线程在内核中对应不同的核心，一个线程在占用资源的时候仍然可以调用该线程下的其他线程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;进程 = 资源 + 指令执行序列&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CPU管理</title>
    <link href="https://shaojunying.github.io/2020/06/09/CPU%E7%AE%A1%E7%90%86/"/>
    <id>https://shaojunying.github.io/2020/06/09/CPU%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU的工作原理"><a href="#CPU的工作原理" class="headerlink" title="CPU的工作原理"></a>CPU的工作原理</h2><p><code>取指执行</code>:根据PC(程序计数器)中的地址,从内存中取得相应的指令,之后执行该指令</p><a id="more"></a><h2 id="管理CPU最直观的方法"><a href="#管理CPU最直观的方法" class="headerlink" title="管理CPU最直观的方法"></a>管理CPU最直观的方法</h2><p><code>设置好PC的初值</code></p><h2 id="该做法的一个问题"><a href="#该做法的一个问题" class="headerlink" title="该做法的一个问题"></a>该做法的一个问题</h2><h3 id="问题展示"><a href="#问题展示" class="headerlink" title="问题展示"></a>问题展示</h3><h4 id="循环中有IO"><a href="#循环中有IO" class="headerlink" title="循环中有IO"></a>循环中有IO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> start = date.getTime();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            a ++;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().getTime() - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一段代码的执行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1640</span><br></pre></td></tr></table></figure><h4 id="循环中没有IO"><a href="#循环中没有IO" class="headerlink" title="循环中没有IO"></a>循环中没有IO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> start = date.getTime();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            a ++;</span><br><span class="line">            a += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().getTime() - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一段代码的执行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>可以看到<code>包含IO的程序</code>每轮循环的执行时间为<code>1.6*10-2</code>ms，而<code>不包含IO的程序</code>每轮循环执行时间为<code>4*10-9</code>ms，IO是非常耗时的操作。如果在程序进行IO操作时CPU一直等待，那么程序的执行效率将会非常低。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>为了解决这个问题，可以在程序正在执行IO等耗时操作时，CPU先执行其他进程，待IO操作执行完毕之后，再将CPU切换回来，继续执行该程序的后续操作。这样可以实现多个程序的并发，显著提高CPU的利用率。</p><p><code>并发</code>: 同时出发，交替执行。</p><h2 id="程序切换时的问题"><a href="#程序切换时的问题" class="headerlink" title="程序切换时的问题"></a>程序切换时的问题</h2><h3 id="问题展示-1"><a href="#问题展示-1" class="headerlink" title="问题展示"></a>问题展示</h3><p>程序1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">50: mov ax 1</span><br><span class="line">51: mov bx 1</span><br><span class="line">52: add ax bx</span><br></pre></td></tr></table></figure><p>程序2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200：mov ax 10</span><br><span class="line">201：mov bx 10</span><br><span class="line">202：add ax bx</span><br></pre></td></tr></table></figure><p>程序从50开始执行，执行完51之后切换到200并开始执行，执行完201之后切换程序1开始执行52行，程序1的结果为20，而原本程序1的结果应该为2。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>为了解决这一问题，需要在程序切换时保存程序的状态。例如，在51行执行结束切换到200时，应该有一个结构保存当前执行到的行号、ax、bx的值等信息。每个程序都应该有一个这样的结构，这个结构被称为<code>PCB</code>（进程管理块）。</p><p>只有这样的运行中的程序需要记录状态信息，而存储起来的静态程序不需要记录这些信息，我们将这些运行中的程序称为<code>进程</code>。</p><p>进程与静态程序的区别：</p><ul><li>进程有开始、暂停、结束等状态；而静态程序没有。</li><li>进程需要记录各个变量（如ax、bx）的信息；而静态程序不用。</li><li>进程会走走停停；而静态程序不会。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作系统执行一段程序，则CPU开始工作，但是如果CPU一直等待一个程序结束才开始别的程序，则IO等耗时操作可能导致CPU利用率过低，为此我们引入了<code>并发</code>的概念，并发的过程中可能会造成一个程序覆盖另一个程序的数据，为此，我们引入了<code>进程</code>的概念，在进程切换时，会使用一个名为<code>PCB</code>的结构保存程序的状态信息。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CPU的工作原理&quot;&gt;&lt;a href=&quot;#CPU的工作原理&quot; class=&quot;headerlink&quot; title=&quot;CPU的工作原理&quot;&gt;&lt;/a&gt;CPU的工作原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;取指执行&lt;/code&gt;:根据PC(程序计数器)中的地址,从内存中取得相应的指令,之后执行该指令&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>多进程图像</title>
    <link href="https://shaojunying.github.io/2020/06/09/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%9B%BE%E5%83%8F/"/>
    <id>https://shaojunying.github.io/2020/06/09/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%9B%BE%E5%83%8F/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用户使用计算机就是启动一堆进程，用户管理计算机就是管理这一堆进程。</p><a id="more"></a><h2 id="多进程的组织：PCB-队列-状态"><a href="#多进程的组织：PCB-队列-状态" class="headerlink" title="多进程的组织：PCB + 队列 + 状态"></a>多进程的组织：PCB + 队列 + 状态</h2><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>操作系统是使用PCB来感知进程的。PCB存储了进程的信息和各种状态。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>内存中的进程有三个状态，分别是进行中、排队等待中、等待事件中。其中对于排队等待中和等待事件中的进程，操作系统都是将其PCB创建一个队列进行管理的。</p><p>进程的状态转移图如下图所示：<br><img src="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程转换图"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>阻塞态和就绪态的进程都是使用队列来管理进程的PCB。</p><h2 id="多进程引发的问题"><a href="#多进程引发的问题" class="headerlink" title="多进程引发的问题"></a>多进程引发的问题</h2><h3 id="多进程在内存中互相影响"><a href="#多进程在内存中互相影响" class="headerlink" title="多进程在内存中互相影响"></a>多进程在内存中互相影响</h3><p>两个不同的进程可能会对同一块地址进行写操作，进而造成进程的崩溃。</p><p>为了解决这个问题，引入了多进程的地址空间分离，即内存管理。将不同内存操作的内存地址映射到不同的内存区域。例如，进程1访问地址为100的内存，最终映射到了地址为780的区域；而进程2访问地址为100的内存是则会被映射到地址为1260的内存区域。从而避免了不同进程之间的互相影响。</p><p><code>进程管理+内存管理=多进程映像</code></p><h3 id="多进程的合作"><a href="#多进程的合作" class="headerlink" title="多进程的合作"></a>多进程的合作</h3><p>多个进程同时向打印机的缓冲队列中同一块区域写入数据，可能会造成冲突。这个问题类似于生产者和消费者问题。</p><p>多个进程同时进行写操作，可能会造成意想不到的结果。例如起始时资源数量为5，两个进程同时分别进行生产和消费，则最终可能的资源数为4或6，最终导致进程崩溃。</p><p>为了解决这个问题，在准备写时，需要首先检查指定资源是否被上锁，如果被上锁要等到锁被释放，否则首先对资源上锁，之后再进行写操作。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;用户使用计算机就是启动一堆进程，用户管理计算机就是管理这一堆进程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机基础" scheme="https://shaojunying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://shaojunying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置categories和tags</title>
    <link href="https://shaojunying.github.io/2020/06/04/Hexo%E9%85%8D%E7%BD%AErepository%E5%92%8Ctags/"/>
    <id>https://shaojunying.github.io/2020/06/04/Hexo%E9%85%8D%E7%BD%AErepository%E5%92%8Ctags/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考 <a href="https://www.zhihu.com/question/29017171/answer/364705653">https://www.zhihu.com/question/29017171/answer/364705653</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于Hexo搭建页面之后categories和tags无法显示</p><a id="more"></a><h2 id="解决方案-以categories为例"><a href="#解决方案-以categories为例" class="headerlink" title="解决方案(以categories为例)"></a>解决方案(以categories为例)</h2><p>首先使用如下命令创建一个categories文件夹,在文件夹内创建一个index.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>之后将<code>source\categories\index.md</code>的内容改为如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>之后在博客中使用如下方式即可创建和使用categories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo配置categories和tags</span><br><span class="line">categories: </span><br><span class="line">- 博客搭建</span><br><span class="line">- Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://www.zhihu.com/question/29017171/answer/364705653&quot;&gt;https://www.zhihu.com/question/29017171/answer/364705653&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;基于Hexo搭建页面之后categories和tags无法显示&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客搭建" scheme="https://shaojunying.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Hexo" scheme="https://shaojunying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://shaojunying.github.io/2020/06/03/first/"/>
    <id>https://shaojunying.github.io/2020/06/03/first/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题一"><a href="#标题一" class="headerlink" title="标题一"></a>标题一</h2><p>内容</p><a id="more"></a><h2 id="标题二"><a href="#标题二" class="headerlink" title="标题二"></a>标题二</h2><p>内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;标题一&quot;&gt;&lt;a href=&quot;#标题一&quot; class=&quot;headerlink&quot; title=&quot;标题一&quot;&gt;&lt;/a&gt;标题一&lt;/h2&gt;&lt;p&gt;内容&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="https://shaojunying.github.io/tags/web%E5%89%8D%E7%AB%AF/"/>
    
    <category term="测试" scheme="https://shaojunying.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shaojunying.github.io/2020/06/03/hello-world/"/>
    <id>https://shaojunying.github.io/2020/06/03/hello-world/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2021-04-04T05:42:02.664Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
